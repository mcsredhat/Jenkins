
pipeline {
    agent any

    environment {
        DOCKER_REGISTRY = 'https://index.docker.io/v1/'
        DOCKER_USERNAME = 'farajassulai'
        DOCKER_REPO = 'php-mysql-app'
        IMAGE_NAME = "${DOCKER_USERNAME}/${DOCKER_REPO}"
        BUILD_TAG = "${env.BUILD_NUMBER}-${env.GIT_COMMIT?.take(7) ?: 'unknown'}"
        CONTAINER_NAME = "php-mysql-project"
        TEST_CONTAINER_NAME = "php-mysql-test-${env.BUILD_NUMBER}"
        GITHUB_REPO = 'https://github.com/mcsredhat/Jenkins'
        APP_DIR = "PHP_DB"
        SKIP_SECURITY_SCAN = 'false'
        ENABLE_DOCKER_PUSH = 'true'
        ENABLE_STAGING_DEPLOY = 'true'
        ENABLE_PRODUCTION_DEPLOY = 'true'
        FORCE_BRANCH_MAIN = 'true'
        FORCE_BRANCH_DEVELOP = 'false'
        EMAIL_CONFIGURED = 'false'
        COMPOSE_PROJECT_NAME = "php-mysql-app-${env.BUILD_NUMBER}"
        TEST_COMPOSE_PROJECT_NAME = "php-mysql-test-${env.BUILD_NUMBER}"
    }

    stages {
        stage('Checkout') {
            steps {
                echo "Checking out code from GitHub repository..."
                checkout scm

                script {
                    echo "Current branch: ${env.BRANCH_NAME ?: 'main'}"
                    echo "Git commit: ${env.GIT_COMMIT ?: 'unknown'}"
                    echo "Repository URL: ${GITHUB_REPO}"
                    echo "Working in directory: ${pwd()}"
                    echo "Application directory: ${APP_DIR}"
                    
                    dir("${APP_DIR}") {
                        sh """
                            pwd && ls -la
                        """
                        echo "Checking Docker environment..."
                        sh """
                            docker --version || echo "Docker not found"
                            docker compose version 2>/dev/null && echo "Docker Compose (plugin) available" || echo "Docker Compose plugin not found"
                            docker-compose --version 2>/dev/null && echo "Docker Compose (standalone) available" || echo "Docker Compose standalone not found"
                        """
                        echo "Checking project structure..."
                        sh """
                            ls -la ./mysql/ ./mysql/config ./php-apache/ ./php-apache/src ./php-apache/apache-config ./php-apache/php-config 2>/dev/null || echo 'Some project directories not found - will be created'
                            ls -la docker-compose.yml .env || echo 'Docker Compose files not found'
                            ls -la ./mysql/Dockerfile ./php-apache/Dockerfile 2>/dev/null || echo 'Some Dockerfiles not found'
                        """
                    }
                }
            }
        }

        stage('Setup Environment') {
            steps {
                echo "Setting up environment..."
                script {
                    dir("${APP_DIR}") {
                        sh """
                            # Ensure Jenkins user has permissions
                            whoami
                            sudo chown -R \$(whoami):\$(whoami) . || echo "Warning: Could not change ownership of ${APP_DIR}"
                            sudo chmod -R u+w . || echo "Warning: Could not set write permissions for ${APP_DIR}"
                            
                            # Create necessary directories as specified in .env
                            mkdir -p php-apache/src mysql/config mysql/init || true 
                            mkdir -p php-apache/apache-config php-apache/php-config || true 
                            mkdir -p ./volumes/test/php_data ./volumes/test/php_logs ./volumes/test/mysql_data ./volumes/test/mysql_logs || true 
                            mkdir -p mysql_data1 || true 
                            
                            # Set permissions with fallback
                            chmod -R 755 ./volumes ./volumes/test ./volumes/test/php_data ./volumes/test/php_logs ./volumes/test/mysql_data ./volumes/test/mysql_logs mysql_data1 ./mysql/init 2>/dev/null || echo "Warning: Could not set permissions"
                            chown -R \$(whoami):\$(whoami) ./volumes mysql_data1 ./mysql/init 2>/dev/null || echo "Warning: Could not change ownership"
                            
                            # Validate .env exists
                            if [ ! -f .env ]; then
                                echo "Error: .env file not found in \$(pwd)"
                                ls -la
                                exit 1
                            fi
                            
                            # Create Dockerfiles if they don't exist
                            if [ ! -f ./php-apache/Dockerfile ]; then
                                echo "Creating PHP-Apache Dockerfile..."
                                cat > ./php-apache/Dockerfile << 'EOF'
ARG PHP_VERSION=8.1-apache
FROM php:\${PHP_VERSION}

# Install required PHP extensions and tools
RUN apt-get update && apt-get install -y \\
    libpng-dev \\
    libjpeg-dev \\
    libfreetype6-dev \\
    zip \\
    unzip \\
    curl \\
    && docker-php-ext-configure gd --with-freetype --with-jpeg \\
    && docker-php-ext-install -j\$(nproc) gd pdo pdo_mysql mysqli \\
    && apt-get clean && rm -rf /var/lib/apt/lists/*

# Set working directory
WORKDIR /var/www/html

# Copy application files
COPY php-apache/src/ /var/www/html/

# Set proper permissions
RUN chown -R www-data:www-data /var/www/html \\
    && chmod -R 755 /var/www/html

# Create health check endpoint
RUN echo "<?php echo 'OK'; ?>" > /var/www/html/health.php

EXPOSE 80

CMD ["apache2-foreground"]
EOF
                            fi

                            if [ ! -f ./mysql/Dockerfile ]; then
                                echo "Creating MySQL Dockerfile..."
                                cat > ./mysql/Dockerfile << 'EOF'
ARG MYSQL_VERSION=8.0
FROM mysql:\${MYSQL_VERSION}

# Copy initialization scripts
COPY mysql/init/ /docker-entrypoint-initdb.d/

# Set proper permissions
RUN chmod -R 755 /docker-entrypoint-initdb.d/

EXPOSE 3306
EOF
                            fi

                            # Create basic PHP application if it doesn't exist
                            if [ ! -f ./php-apache/src/index.php ]; then
                                echo "Creating basic PHP application..."
                                cat > ./php-apache/src/index.php << 'EOF'
<?php
\$host = getenv('MYSQL_HOST') ?: 'mysql-db';
\$port = getenv('MYSQL_PORT') ?: '3306';
\$dbname = getenv('MYSQL_DATABASE') ?: 'test_db';
\$username = getenv('MYSQL_USER') ?: 'test_user';
\$password = getenv('MYSQL_PASSWORD') ?: 'test_password';

try {
    \$pdo = new PDO("mysql:host=\$host;port=\$port;dbname=\$dbname", \$username, \$password);
    \$pdo->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);
    
    echo "<h1>PHP-MySQL Application</h1>";
    echo "<p>Database connection: <strong style='color: green;'>SUCCESS</strong></p>";
    echo "<p>Host: \$host:\$port</p>";
    echo "<p>Database: \$dbname</p>";
    echo "<p>User: \$username</p>";
    echo "<p>Environment: " . (getenv('PHP_ENV') ?: 'test') . "</p>";
    echo "<p>Timestamp: " . date('Y-m-d H:i:s') . "</p>";
    
} catch(PDOException \$e) {
    echo "<h1>PHP-MySQL Application</h1>";
    echo "<p>Database connection: <strong style='color: red;'>FAILED</strong></p>";
    echo "<p>Error: " . \$e->getMessage() . "</p>";
}
?>
EOF
                            fi

                            # Create health check endpoint
                            if [ ! -f ./php-apache/src/health.php ]; then
                                echo "<?php echo 'OK'; ?>" > ./php-apache/src/health.php
                            fi

                            # Create basic MySQL init script
                            if [ ! -f ./mysql/init/01-init.sql ]; then
                                cat > ./mysql/init/01-init.sql << 'EOF'
-- Create application database if not exists
CREATE DATABASE IF NOT EXISTS test_db;

-- Create test table
USE test_db;
CREATE TABLE IF NOT EXISTS users (
    id INT AUTO_INCREMENT PRIMARY KEY,
    username VARCHAR(50) NOT NULL UNIQUE,
    email VARCHAR(100) NOT NULL UNIQUE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Insert sample data
INSERT IGNORE INTO users (username, email) VALUES 
('testuser1', 'test1@example.com'),
('testuser2', 'test2@example.com');
EOF
                            fi
                            
                            # Stop any existing containers
                            docker compose -p ${COMPOSE_PROJECT_NAME} down -v 2>/dev/null || docker-compose -p ${COMPOSE_PROJECT_NAME} down -v 2>/dev/null || echo "No compose services to stop"
                            docker compose -p ${TEST_COMPOSE_PROJECT_NAME} down -v 2>/dev/null || docker-compose -p ${TEST_COMPOSE_PROJECT_NAME} down -v 2>/dev/null || echo "No test compose services to stop"
                            
                            # Clean up any orphaned containers
                            docker container prune -f || true
                            docker volume prune -f || true
                        """
                    }
                }
            }
        }

        stage('Build') {
            steps {
                echo "Building Docker images with Docker Compose..."
                script {
                    dir("${APP_DIR}") {
                        try {
                            def composeCmd = sh(
                                script: "docker compose version >/dev/null 2>&1 && echo 'docker compose' || echo 'docker-compose'",
                                returnStdout: true
                            ).trim()
                            echo "Using compose command: ${composeCmd}"
                            
                            sh """
                                # Validate files exist and have required content
                                pwd
                                ls -la
                                
                                if [ ! -f .env ]; then
                                    echo "Error: .env file not found in \$(pwd)"
                                    echo "Contents of current directory:"
                                    ls -la
                                    exit 1
                                fi
                                
                                if [ ! -f docker-compose.yml ]; then
                                    echo "Error: docker-compose.yml file not found in \$(pwd)"
                                    echo "Contents of current directory:"
                                    ls -la
                                    exit 1
                                fi
                                
                                # Validate required environment variables
                                grep -q "MYSQL_ROOT_PASSWORD=" .env || (echo "Error: MYSQL_ROOT_PASSWORD not found in .env" && exit 1)
                                grep -q "MYSQL_DATABASE=" .env || (echo "Error: MYSQL_DATABASE not found in .env" && exit 1)
                                grep -q "PHP_VERSION=" .env || (echo "Error: PHP_VERSION not found in .env" && exit 1)
                                
                                echo "Environment file validation passed"
                            """
                            
                            sh """
                                COMPOSE_PROJECT_NAME=${COMPOSE_PROJECT_NAME} ${composeCmd} build --no-cache 2>&1 | tee build.log
                                if [ \${PIPESTATUS[0]} -ne 0 ]; then
                                    echo "Docker Compose build failed, displaying build log:"
                                    cat build.log
                                    exit 1
                                fi
                            """
                            
                            sh """
                                # Tag the built images for Docker Hub
                                PHP_IMAGE=\$(docker images --format "table {{.Repository}}:{{.Tag}}" | grep "${COMPOSE_PROJECT_NAME}" | grep php | head -1 | awk '{print \$1}' || echo "")
                                if [ ! -z "\$PHP_IMAGE" ]; then
                                    docker tag \$PHP_IMAGE ${IMAGE_NAME}:${BUILD_TAG}
                                    docker tag \$PHP_IMAGE ${IMAGE_NAME}:latest
                                    echo "Tagged PHP image: \$PHP_IMAGE -> ${IMAGE_NAME}:${BUILD_TAG}"
                                else
                                    # Alternative: find any image with php-apache in the name
                                    PHP_IMAGE=\$(docker images | grep php-apache | head -1 | awk '{print \$1":"\$2}' || echo "")
                                    if [ ! -z "\$PHP_IMAGE" ]; then
                                        docker tag \$PHP_IMAGE ${IMAGE_NAME}:${BUILD_TAG}
                                        docker tag \$PHP_IMAGE ${IMAGE_NAME}:latest
                                        echo "Tagged PHP image: \$PHP_IMAGE -> ${IMAGE_NAME}:${BUILD_TAG}"
                                    else
                                        echo "Warning: Could not find PHP image to tag"
                                        echo "Available images:"
                                        docker images
                                    fi
                                fi
                            """
                            
                            echo "Images built successfully with project name: ${COMPOSE_PROJECT_NAME}"
                        } catch (Exception e) {
                            echo "Build failed: ${e.getMessage()}"
                            sh "cat build.log 2>/dev/null || echo 'No build log available'"
                            throw e
                        }
                    }
                }
            }
        }

        stage('Test') {
            steps {
                echo "Running containerized tests with Docker Compose..."
                script {
                    dir("${APP_DIR}") {
                        def composeCmd = sh(
                            script: "docker compose version >/dev/null 2>&1 && echo 'docker compose' || echo 'docker-compose'",
                            returnStdout: true
                        ).trim()
                        
                        // Initialize testConfig
                        def testConfig = [:]
                        
                        try {
                            // Create test environment file
                            sh """
                                # Ensure write permissions for .env-test
                                touch .env-test && chmod 644 .env-test || { echo "Error: Cannot create or set permissions for .env-test"; exit 1; }
                                
                                # Validate .env exists before copying
                                if [ ! -f .env ]; then
                                    echo "Error: .env file not found in \$(pwd)"
                                    ls -la
                                    exit 1
                                fi
                                
                                # Create .env-test from .env with test-specific settings
                                cp .env .env-test || { echo "Error: Cannot copy .env to .env-test"; exit 1; }
                                
                                # Update ports and settings for testing to avoid conflicts
                                sed -i 's/PHP_EXTERNAL_PORT=.*/PHP_EXTERNAL_PORT=8091/' .env-test
                                sed -i 's/MYSQL_EXTERNAL_PORT=.*/MYSQL_EXTERNAL_PORT=3308/' .env-test
                                sed -i 's/ADMINER_EXTERNAL_PORT=.*/ADMINER_EXTERNAL_PORT=8084/' .env-test
                                sed -i 's/MYSQL_DATABASE=.*/MYSQL_DATABASE=test_db/' .env-test
                                sed -i 's/MYSQL_USER=.*/MYSQL_USER=test_user/' .env-test
                                sed -i 's/MYSQL_PASSWORD=.*/MYSQL_PASSWORD=test_password/' .env-test
                                sed -i 's/MYSQL_ROOT_PASSWORD=.*/MYSQL_ROOT_PASSWORD=test_rootpass/' .env-test
                                sed -i 's/PHP_ENV=.*/PHP_ENV=test/' .env-test
                                sed -i 's/MYSQL_APP_ENV=.*/MYSQL_APP_ENV=test/' .env-test
                                sed -i 's/APP_DESCRIPTION=.*/APP_DESCRIPTION="PHP-Apache2 application with MySQL database"/' .env-test
                                sed -i 's/COMPOSE_PROJECT_NAME=.*/COMPOSE_PROJECT_NAME=${TEST_COMPOSE_PROJECT_NAME}/' .env-test
                                sed -i 's/PHP_CONTAINER_NAME=.*/PHP_CONTAINER_NAME=php-apache-test/' .env-test
                                sed -i 's/MYSQL_CONTAINER_NAME=.*/MYSQL_CONTAINER_NAME=mysql-db-test/' .env-test
                                sed -i 's/ADMINER_CONTAINER_NAME=.*/ADMINER_CONTAINER_NAME=adminer-test/' .env-test
                                sed -i 's/PHP_DATA_PATH=.*/PHP_DATA_PATH=.\\/volumes\\/test\\/php_data/' .env-test
                                sed -i 's/PHP_LOGS_PATH=.*/PHP_LOGS_PATH=.\\/volumes\\/test\\/php_logs/' .env-test
                                sed -i 's/MYSQL_DATA_PATH=.*/MYSQL_DATA_PATH=.\\/volumes\\/test\\/mysql_data/' .env-test
                                sed -i 's/MYSQL_LOGS_PATH=.*/MYSQL_LOGS_PATH=.\\/volumes\\/test\\/mysql_logs/' .env-test
                                sed -i 's/NETWORK_SUBNET=.*/NETWORK_SUBNET=172.19.20.0\\/24/' .env-test
                                
                                # Debug: Show contents of .env-test
                                echo "Test environment file created:"
                                cat .env-test
                                
                                # Validate critical variables
                                grep -q "MYSQL_ROOT_PASSWORD=test_rootpass" .env-test || { echo "Error: MYSQL_ROOT_PASSWORD not set correctly in .env-test"; cat .env-test; exit 1; }
                                grep -q "MYSQL_DATABASE=test_db" .env-test || { echo "Error: MYSQL_DATABASE not set correctly in .env-test"; cat .env-test; exit 1; }
                                grep -q "MYSQL_USER=test_user" .env-test || { echo "Error: MYSQL_USER not set correctly in .env-test"; cat .env-test; exit 1; }
                                grep -q "MYSQL_PASSWORD=test_password" .env-test || { echo "Error: MYSQL_PASSWORD not set correctly in .env-test"; cat .env-test; exit 1; }
                                grep -q "MYSQL_CONTAINER_NAME=mysql-db-test" .env-test || { echo "Error: MYSQL_CONTAINER_NAME not set correctly in .env-test"; cat .env-test; exit 1; }
                            """
                            
                            // Extract test configuration
                            sh """
                                # Ensure write permissions for test_config.env
                                touch test_config.env && chmod 644 test_config.env || { echo "Error: Cannot create or set permissions for test_config.env"; exit 1; }
                                
                                # Debug: Check write permissions
                                ls -l test_config.env || { echo "Error: test_config.env not accessible"; exit 1; }
                                
                                # Parse test_config.env
                                echo "Creating test_config.env..."
                                > test_config.env
                                echo "TEST_PHP_PORT=\$(grep '^PHP_EXTERNAL_PORT=' .env-test | cut -d '=' -f2- || echo '8091')" >> test_config.env
                                echo "TEST_MYSQL_PORT=\$(grep '^MYSQL_EXTERNAL_PORT=' .env-test | cut -d '=' -f2- || echo '3308')" >> test_config.env
                                echo "TEST_ADMINER_PORT=\$(grep '^ADMINER_EXTERNAL_PORT=' .env-test | cut -d '=' -f2- || echo '8084')" >> test_config.env
                                echo "TEST_DB_ROOT_PASSWORD=\$(grep '^MYSQL_ROOT_PASSWORD=' .env-test | cut -d '=' -f2- || echo 'test_rootpass')" >> test_config.env
                                echo "TEST_DB_NAME=\$(grep '^MYSQL_DATABASE=' .env-test | cut -d '=' -f2- || echo 'test_db')" >> test_config.env
                                echo "TEST_DB_USER=\$(grep '^MYSQL_USER=' .env-test | cut -d '=' -f2- || echo 'test_user')" >> test_config.env
                                echo "TEST_DB_PASSWORD=\$(grep '^MYSQL_PASSWORD=' .env-test | cut -d '=' -f2- || echo 'test_password')" >> test_config.env
                                echo "TEST_PROJECT_NAME=\$(grep '^COMPOSE_PROJECT_NAME=' .env-test | cut -d '=' -f2- || echo '${TEST_COMPOSE_PROJECT_NAME}')" >> test_config.env
                                echo "TEST_PHP_CONTAINER=\$(grep '^PHP_CONTAINER_NAME=' .env-test | cut -d '=' -f2- || echo 'php-apache-test')" >> test_config.env
                                echo "TEST_MYSQL_CONTAINER=\$(grep '^MYSQL_CONTAINER_NAME=' .env-test | cut -d '=' -f2- || echo 'mysql-db-test')" >> test_config.env
                                echo "TEST_ADMINER_CONTAINER=\$(grep '^ADMINER_CONTAINER_NAME=' .env-test | cut -d '=' -f2- || echo 'adminer-test')" >> test_config.env
                                
                                # Debug: Show contents of test_config.env
                                echo "Contents of test_config.env:"
                                cat test_config.env
                                
                                # Validate critical variables
                                grep -q "TEST_DB_ROOT_PASSWORD=test_rootpass" test_config.env || { echo "Error: TEST_DB_ROOT_PASSWORD not set correctly in test_config.env"; cat test_config.env; exit 1; }
                                grep -q "TEST_DB_NAME=test_db" test_config.env || { echo "Error: TEST_DB_NAME not set correctly in test_config.env"; cat test_config.env; exit 1; }
                                grep -q "TEST_DB_USER=test_user" test_config.env || { echo "Error: TEST_DB_USER not set correctly in test_config.env"; cat test_config.env; exit 1; }
                                grep -q "TEST_DB_PASSWORD=test_password" test_config.env || { echo "Error: TEST_DB_PASSWORD not set correctly in test_config.env"; cat test_config.env; exit 1; }
                                grep -q "TEST_MYSQL_CONTAINER=mysql-db-test" test_config.env || { echo "Error: TEST_MYSQL_CONTAINER not set correctly in test_config.env"; cat test_config.env; exit 1; }
                                
                                # Source the test_config.env to set environment variables
                                . ./test_config.env
                                
                                # Verify extracted variables
                                echo "Extracted TEST_PHP_PORT: \$TEST_PHP_PORT"
                                echo "Extracted TEST_MYSQL_PORT: \$TEST_MYSQL_PORT"
                                echo "Extracted TEST_ADMINER_PORT: \$TEST_ADMINER_PORT"
                                echo "Extracted TEST_DB_ROOT_PASSWORD: \$TEST_DB_ROOT_PASSWORD"
                                echo "Extracted TEST_DB_NAME: \$TEST_DB_NAME"
                                echo "Extracted TEST_DB_USER: \$TEST_DB_USER"
                                echo "Extracted TEST_DB_PASSWORD: \$TEST_DB_PASSWORD"
                                echo "Extracted TEST_PROJECT_NAME: \$TEST_PROJECT_NAME"
                                echo "Extracted TEST_PHP_CONTAINER: \$TEST_PHP_CONTAINER"
                                echo "Extracted TEST_MYSQL_CONTAINER: \$TEST_MYSQL_CONTAINER"
                                echo "Extracted TEST_ADMINER_CONTAINER: \$TEST_ADMINER_CONTAINER"
                            """
                            
                            // Populate testConfig map
                            try {
                                testConfig['TEST_PHP_PORT'] = sh(script: "grep '^TEST_PHP_PORT=' ${APP_DIR}/test_config.env | cut -d '=' -f2- || echo '8091'", returnStdout: true).trim()
                                testConfig['TEST_MYSQL_PORT'] = sh(script: "grep '^TEST_MYSQL_PORT=' ${APP_DIR}/test_config.env | cut -d '=' -f2- || echo '3308'", returnStdout: true).trim()
                                testConfig['TEST_ADMINER_PORT'] = sh(script: "grep '^TEST_ADMINER_PORT=' ${APP_DIR}/test_config.env | cut -d '=' -f2- || echo '8084'", returnStdout: true).trim()
                                testConfig['TEST_DB_ROOT_PASSWORD'] = sh(script: "grep '^TEST_DB_ROOT_PASSWORD=' ${APP_DIR}/test_config.env | cut -d '=' -f2- || echo 'test_rootpass'", returnStdout: true).trim()
                                testConfig['TEST_DB_NAME'] = sh(script: "grep '^TEST_DB_NAME=' ${APP_DIR}/test_config.env | cut -d '=' -f2- || echo 'test_db'", returnStdout: true).trim()
                                testConfig['TEST_DB_USER'] = sh(script: "grep '^TEST_DB_USER=' ${APP_DIR}/test_config.env | cut -d '=' -f2- || echo 'test_user'", returnStdout: true).trim()
                                testConfig['TEST_DB_PASSWORD'] = sh(script: "grep '^TEST_DB_PASSWORD=' ${APP_DIR}/test_config.env | cut -d '=' -f2- || echo 'test_password'", returnStdout: true).trim()
                                testConfig['TEST_PROJECT_NAME'] = sh(script: "grep '^TEST_PROJECT_NAME=' ${APP_DIR}/test_config.env | cut -d '=' -f2- || echo '${TEST_COMPOSE_PROJECT_NAME}'", returnStdout: true).trim()
                                testConfig['TEST_PHP_CONTAINER'] = sh(script: "grep '^TEST_PHP_CONTAINER=' ${APP_DIR}/test_config.env | cut -d '=' -f2- || echo 'php-apache-test'", returnStdout: true).trim()
                                testConfig['TEST_MYSQL_CONTAINER'] = sh(script: "grep '^TEST_MYSQL_CONTAINER=' ${APP_DIR}/test_config.env | cut -d '=' -f2- || echo 'mysql-db-test'", returnStdout: true).trim()
                                testConfig['TEST_ADMINER_CONTAINER'] = sh(script: "grep '^TEST_ADMINER_CONTAINER=' ${APP_DIR}/test_config.env | cut -d '=' -f2- || echo 'adminer-test'", returnStdout: true).trim()
                                
                                // Debug: Verify extracted variables in Groovy
                                echo "Groovy extracted TEST_PHP_PORT: ${testConfig.TEST_PHP_PORT}"
                                echo "Groovy extracted TEST_MYSQL_PORT: ${testConfig.TEST_MYSQL_PORT}"
                                echo "Groovy extracted TEST_ADMINER_PORT: ${testConfig.TEST_ADMINER_PORT}"
                                echo "Groovy extracted TEST_DB_ROOT_PASSWORD: ${testConfig.TEST_DB_ROOT_PASSWORD}"
                                echo "Groovy extracted TEST_DB_NAME: ${testConfig.TEST_DB_NAME}"
                                echo "Groovy extracted TEST_DB_USER: ${testConfig.TEST_DB_USER}"
                                echo "Groovy extracted TEST_DB_PASSWORD: ${testConfig.TEST_DB_PASSWORD}"
                                echo "Groovy extracted TEST_PROJECT_NAME: ${testConfig.TEST_PROJECT_NAME}"
                                echo "Groovy extracted TEST_PHP_CONTAINER: ${testConfig.TEST_PHP_CONTAINER}"
                                echo "Groovy extracted TEST_MYSQL_CONTAINER: ${testConfig.TEST_MYSQL_CONTAINER}"
                                echo "Groovy extracted TEST_ADMINER_CONTAINER: ${testConfig.TEST_ADMINER_CONTAINER}"
                            } catch (Exception e) {
                                echo "Failed to populate testConfig: ${e.getMessage()}"
                                error "Cannot proceed without valid testConfig"
                            }
                            
                            // Validate critical variables
                            if (!testConfig.TEST_DB_ROOT_PASSWORD || testConfig.TEST_DB_ROOT_PASSWORD == 'null' || testConfig.TEST_DB_ROOT_PASSWORD == '') {
                                error "TEST_DB_ROOT_PASSWORD is empty or null (value: ${testConfig.TEST_DB_ROOT_PASSWORD})"
                            }
                            if (!testConfig.TEST_MYSQL_CONTAINER || testConfig.TEST_MYSQL_CONTAINER != 'mysql-db-test') {
                                error "TEST_MYSQL_CONTAINER is not set to 'mysql-db-test' (value: ${testConfig.TEST_MYSQL_CONTAINER})"
                            }
                            
                            sh """
                                echo "Starting test services with .env-test configuration..."
                                ${composeCmd} --env-file .env-test up -d --build
                            """
                            
                            echo "Waiting for test services to start..."
                            sleep 60
                            
                            // Debug: Check container status before tests
                            sh """
                                echo "=== Test Container Status ==="
                                ${composeCmd} --env-file .env-test ps
                                docker ps -a | grep ${TEST_COMPOSE_PROJECT_NAME} || echo "No containers found for ${TEST_COMPOSE_PROJECT_NAME}"
                            """
                            
                            // Wait for MySQL to be ready
                            retry(20) {
                                sleep(10)
                                sh """
                                    ${composeCmd} --env-file .env-test exec -T ${testConfig.TEST_MYSQL_CONTAINER} mysqladmin ping -h mysql-db -u root --password="${testConfig.TEST_DB_ROOT_PASSWORD}" --connect-timeout=10
                                """
                            }
                            
                            echo "MySQL is ready! Running comprehensive tests..."
                            
                            // Database tests
                            sh """
                                echo "Testing database connectivity and operations..."
                                ${composeCmd} --env-file .env-test exec -T ${testConfig.TEST_MYSQL_CONTAINER} mysql -uroot -p"${testConfig.TEST_DB_ROOT_PASSWORD}" -h mysql-db -e "SHOW DATABASES;"
                                
                                echo "Testing database '${testConfig.TEST_DB_NAME}' exists..."
                                ${composeCmd} --env-file .env-test exec -T ${testConfig.TEST_MYSQL_CONTAINER} mysql -uroot -p"${testConfig.TEST_DB_ROOT_PASSWORD}" -h mysql-db -e "USE ${testConfig.TEST_DB_NAME}; SELECT 'Database connection successful' as status;"
                                
                                echo "Testing regular user access..."
                                ${composeCmd} --env-file .env-test exec -T ${testConfig.TEST_MYSQL_CONTAINER} mysql -u${testConfig.TEST_DB_USER} -p"${testConfig.TEST_DB_PASSWORD}" -h mysql-db -e "USE ${testConfig.TEST_DB_NAME}; SELECT COUNT(*) as user_count FROM users;"
                            """
                            
                            // Application tests
                            sh """
                                echo "Testing PHP application on port ${testConfig.TEST_PHP_PORT}..."
                                sleep 10
                                curl -f --connect-timeout 15 --max-time 45 http://localhost:${testConfig.TEST_PHP_PORT}/ || { 
                                    echo "PHP application test failed on port ${testConfig.TEST_PHP_PORT} - checking container status"; 
                                    ${composeCmd} --env-file .env-test ps; 
                                    ${composeCmd} --env-file .env-test logs ${testConfig.TEST_PHP_CONTAINER}; 
                                    exit 1; 
                                }
                                
                                echo "Testing Adminer interface on port ${testConfig.TEST_ADMINER_PORT}..."
                                curl -f --connect-timeout 15 --max-time 45 http://localhost:${testConfig.TEST_ADMINER_PORT}/ || { 
                                    echo "Adminer interface test failed on port ${testConfig.TEST_ADMINER_PORT} - checking container status"; 
                                    ${composeCmd} --env-file .env-test ps; 
                                    ${composeCmd} --env-file .env-test logs ${testConfig.TEST_ADMINER_CONTAINER}; 
                                    exit 1; 
                                }
                                
                                echo "Testing health check endpoint..."
                                curl -f --connect-timeout 15 --max-time 30 "http://localhost:${testConfig.TEST_PHP_PORT}/health.php" || { 
                                    echo "Health check endpoint test failed"; 
                                    exit 1;
                                }
                            """
                            
                            echo "All tests passed successfully!"
                            echo "Test Environment Summary:"
                            echo "- PHP Application: http://localhost:${testConfig.TEST_PHP_PORT}"
                            echo "- Adminer: http://localhost:${testConfig.TEST_ADMINER_PORT}"
                            echo "- MySQL Connection: mysql -h127.0.0.1 -P${testConfig.TEST_MYSQL_PORT} -uroot -p${testConfig.TEST_DB_ROOT_PASSWORD}"
                            echo "- Test Database: ${testConfig.TEST_DB_NAME}"
                            echo "- Project Name: ${testConfig.TEST_PROJECT_NAME}"
                            echo "- PHP Container: ${testConfig.TEST_PHP_CONTAINER}"
                            echo "- MySQL Container: ${testConfig.TEST_MYSQL_CONTAINER}"
                            echo "- Adminer Container: ${testConfig.TEST_ADMINER_CONTAINER}"
                            
                        } catch (Exception e) {
                            echo "Test failed: ${e.getMessage()}"
                            sh """
                                echo "=== Test Environment Debug Information ==="
                                echo "Current directory: \$(pwd)"
                                echo "Environment files:"
                                ls -la .env* test_config.env 2>/dev/null || echo 'No environment files found'
                                cat .env 2>/dev/null || echo "Could not read .env"
                                cat .env-test 2>/dev/null || echo "Could not read .env-test"
                                cat test_config.env 2>/dev/null || echo "Could not read test_config.env"
                                
                                echo "=== Container Status ==="
                                ${composeCmd} --env-file .env-test ps 2>/dev/null || echo 'Could not retrieve container status'
                                
                                echo "=== MySQL Logs ==="
                                ${composeCmd} --env-file .env-test logs mysql-db-test | tail -50 2>/dev/null || echo 'Could not retrieve MySQL logs'
                                
                                echo "=== PHP App Logs ==="
                                ${composeCmd} --env-file .env-test logs php-apache-test | tail -50 2>/dev/null || echo 'Could not retrieve PHP logs'
                                
                                echo "=== Adminer Logs ==="
                                ${composeCmd} --env-file .env-test logs adminer-test | tail -50 2>/dev/null || echo 'Could not retrieve Adminer logs'
                                
                                echo "=== Network Information ==="
                                docker network ls
                                docker ps -a | grep ${TEST_COMPOSE_PROJECT_NAME} || echo "No test containers found"
                                
                                echo "=== Port Status ==="
                                netstat -tlnp | grep -E ":(8091|3308|8084)" 2>/dev/null || echo "No test ports found in use"
                                
                                echo "=== Permissions Check ==="
                                ls -ld . ./volumes ./volumes/test 2>/dev/null || echo "Cannot access directories"
                                ls -l .env .env-test test_config.env 2>/dev/null || echo "Cannot access environment files"
                            """
                            throw e
                        } finally {
                            sh """
                                echo "Cleaning up test environment..."
                                ${composeCmd} --env-file .env-test down -v --remove-orphans 2>/dev/null || true
                                docker compose -p ${TEST_COMPOSE_PROJECT_NAME} down -v 2>/dev/null || true
                                docker-compose -p ${TEST_COMPOSE_PROJECT_NAME} down -v 2>/dev/null || true
                                rm -f test_config.env .env-test 2>/dev/null || true
                                
                                # Clean up any dangling containers and volumes
                                docker container prune -f || true
                                docker volume prune -f --filter "label=com.docker.compose.project=${TEST_COMPOSE_PROJECT_NAME}" || true
                                docker volume prune -f --filter "label=com.docker.compose.project=php-mysql-app" || true
                            """
                        }
                    }
                }
            }
        }

        stage('Security Scan') {
            when {
                anyOf {
                    environment name: 'SKIP_SECURITY_SCAN', value: 'false'
                    environment name: 'FORCE_SECURITY_SCAN', value: 'true'
                }
            }
            steps {
                echo "Running security scan with Trivy..."
                script {
                    dir("${APP_DIR}") {
                        try {
                            def trivyAvailable = sh(
                                script: "docker run --rm aquasec/trivy:latest --version",
                                returnStatus: true
                            )
                            if (trivyAvailable != 0) {
                                echo "Trivy not available, skipping security scan"
                                currentBuild.result = 'UNSTABLE'
                                return
                            }
                            
                            sh """
                                docker run --rm -v /var/run/docker.sock:/var/run/docker.sock \\
                                    aquasec/trivy:latest image \\
                                    --format table \\
                                    --severity LOW,MEDIUM,HIGH,CRITICAL \\
                                    ${IMAGE_NAME}:${BUILD_TAG} || true
                            """
                            
                            def criticalScanResult = sh(
                                script: """
                                    docker run --rm -v /var/run/docker.sock:/var/run/docker.sock \\
                                        aquasec/trivy:latest image \\
                                        --exit-code 1 --severity CRITICAL \\
                                        --format table \\
                                        ${IMAGE_NAME}:${BUILD_TAG} || true
                                """,
                                returnStatus: true
                            )
                            
                            if (criticalScanResult == 0) {
                                echo "No CRITICAL vulnerabilities found"
                            } else {
                                echo "CRITICAL vulnerabilities found - marking build as unstable"
                                currentBuild.result = 'UNSTABLE'
                            }
                            echo "Security scan completed"
                        } catch (Exception e) {
                            echo "Security scan failed: ${e.getMessage()}"
                            currentBuild.result = 'UNSTABLE'
                        }
                    }
                }
            }
        }

        stage('Push to Docker Hub') {
            when {
                anyOf {
                    branch 'main'
                    branch 'develop'
                    environment name: 'ENABLE_DOCKER_PUSH', value: 'true'
                    environment name: 'FORCE_BRANCH_MAIN', value: 'true'
                    environment name: 'FORCE_BRANCH_DEVELOP', value: 'true'
                }
            }
            steps {
                echo "Pushing image to Docker Hub..."
                script {
                    dir("${APP_DIR}") {
                        try {
                            docker.withRegistry("${DOCKER_REGISTRY}", 'dockerhub-credentials') {
                                def image = docker.image("${IMAGE_NAME}:${BUILD_TAG}")
                                image.push()
                                image.push("jenkins-latest")
                                if (env.BRANCH_NAME == 'main' || env.FORCE_BRANCH_MAIN == 'true') {
                                    image.push("production")
                                    image.push("v1.0.0")
                                } else if (env.BRANCH_NAME == 'develop' || env.FORCE_BRANCH_DEVELOP == 'true') {
                                    image.push("staging")
                                    image.push("develop-latest")
                                }
                                echo "Image pushed successfully with credentials"
                            }
                        } catch (Exception credError) {
                            echo "Docker Hub credentials not found, attempting push without registry authentication..."
                            sh """
                                docker push ${IMAGE_NAME}:${BUILD_TAG} ||bok  echo "Push failed - check Docker Hub login"
                                docker push ${IMAGE_NAME}:jenkins-latest || echo "Push failed - check Docker Hub login"
                            """
                            echo "Image push attempted (check Docker Hub for results)"
                        }
                    }
                }
            }
        }

        stage('Deploy to Staging') {
            when {
                anyOf {
                    branch 'develop'
                    environment name: 'ENABLE_STAGING_DEPLOY', value: 'true'
                    environment name: 'FORCE_BRANCH_DEVELOP', value: 'true'
                }
            }
            steps {
                echo "Deploying to staging..."
                script {
                    dir("${APP_DIR}") {
                        deployToEnvironment('staging', '8090', '3307', '8083')
                    }
                }
            }
        }

        stage('Deploy to Production') {
            when {
                anyOf {
                    branch 'main'
                    environment name: 'ENABLE_PRODUCTION_DEPLOY', value: 'true'
                    environment name: 'FORCE_BRANCH_MAIN', value: 'true'
                }
            }
            steps {
                script {
                    dir("${APP_DIR}") {
                        if (env.SKIP_PRODUCTION_APPROVAL != 'true') {
                            try {
                                timeout(time: 5, unit: 'MINUTES') {
                                    input message: 'Deploy to production?', ok: 'Deploy'
                                }
                            } catch (Exception e) {
                                echo "Production deployment approval timeout or skipped"
                                return
                            }
                        }
                        echo "Deploying to production..."
                        deployToEnvironment('production', '8088', '3306', '8082')
                    }
                }
            }
        }
    }

    post {
        always {
            echo "Cleaning up..."
            script {
                dir("${APP_DIR}") {
                    sh """
                        docker compose -p ${TEST_COMPOSE_PROJECT_NAME} down -v 2>/dev/null || true
                        docker-compose -p ${TEST_COMPOSE_PROJECT_NAME} down -v 2>/dev/null || true
                        docker compose -p php-mysql-app-staging down -v 2>/dev/null || true
                        docker-compose -p php-mysql-app-staging down -v 2>/dev/null || true
                        docker compose -p php-mysql-app-production down -v 2>/dev/null || true
                        docker-compose -p php-mysql-app-production down -v 2>/dev/null || true
                        docker system prune -f --filter "until=24h" || true
                        rm -f .env.test .env.staging .env.production test_config.env 2>/dev/null || true
                        
                        # Additional cleanup for stray containers
                        docker ps -a | grep -E 'mysql-db|php-apache|adminer' | awk '{print \$1}' | xargs -r docker rm -f || true
                    """
                }
            }
        }

        success {
            echo "Pipeline completed successfully!"
            script {
                try {
                    if (env.EMAIL_CONFIGURED == 'true') {
                        emailext(
                            subject: "PHP-MySQL Build Success: ${env.JOB_NAME} #${env.BUILD_NUMBER}",
                            body: """
                                PHP-MySQL application build succeeded!

                                Job: ${env.JOB_NAME}
                                Build Number: ${env.BUILD_NUMBER}
                                Branch: ${env.BRANCH_NAME ?: 'main'}
                                Image: ${IMAGE_NAME}:${BUILD_TAG}
                                Application Directory: ${APP_DIR}

                                GitHub: ${GITHUB_REPO}
                                Docker Hub: https://hub.docker.com/r/${DOCKER_USERNAME}/${DOCKER_REPO}
                                Build URL: ${env.BUILD_URL}
                            """,
                            recipientProviders: [developers()]
                        )
                    } else {
                        echo "Email notification skipped - EMAIL_CONFIGURED not set to true"
                    }
                } catch (Exception e) {
                    echo "Failed to send success email: ${e.getMessage()}"
                }
            }
        }

        failure {
            echo "Pipeline failed!"
            script {
                try {
                    if (env.EMAIL_CONFIGURED == 'true') {
                        emailext(
                            subject: "PHP-MySQL Build Failed: ${env.JOB_NAME} #${env.BUILD_NUMBER}",
                            body: """
                                PHP-MySQL application build failed!

                                Job: ${env.JOB_NAME}
                                Branch: ${env.BRANCH_NAME ?: 'main'}
                                Application Directory: ${APP_DIR}
                                Build URL: ${env.BUILD_URL}

                                Please check the console output for details:
                                ${env.BUILD_URL}console
                            """,
                            recipientProviders: [developers(), requestor()]
                        )
                    } else {
                        echo "Email notification skipped - EMAIL_CONFIGURED not set to true"
                    }
                } catch (Exception e) {
                    echo "Failed to send failure email: ${e.getMessage()}"
                }
            }
        }

        unstable {
            echo "Pipeline completed with warnings."
        }
    }
}

def deployToEnvironment(environment, phpPort, mysqlPort, adminerPort) {
    def projectName = "php-mysql-app-${environment}"
    def composeCmd = sh(
        script: "docker compose version >/dev/null 2>&1 && echo 'docker compose' || echo 'docker-compose'",
        returnStdout: true
    ).trim()
    
    try {
        echo "Deploying PHP-MySQL application to ${environment}"
        echo "PHP Port: ${phpPort}, MySQL Port: ${mysqlPort}, Adminer Port: ${adminerPort}"
        
        sh """
            # Ensure write permissions for .env.${environment}
            touch .env.${environment} && chmod 644 .env.${environment} || { echo "Error: Cannot create or set permissions for .env.${environment}"; exit 1; }
            
            cp .env .env.${environment} || { echo "Error: Cannot copy .env to .env.${environment}"; exit 1; }
            
            # Set environment-specific credentials
            if [ "${environment}" = "production" ]; then
                sed -i 's/MYSQL_ROOT_PASSWORD=.*/MYSQL_ROOT_PASSWORD=rootpass123!@#/' .env.${environment}
                sed -i 's/MYSQL_DATABASE=.*/MYSQL_DATABASE=myappdb/' .env.${environment}
                sed -i 's/MYSQL_USER=.*/MYSQL_USER=appuser/' .env.${environment}
                sed -i 's/MYSQL_PASSWORD=.*/MYSQL_PASSWORD=MyAppUserPass456!@#/' .env.${environment}
                sed -i 's/PHP_CONTAINER_NAME=.*/PHP_CONTAINER_NAME=php-apache/' .env.${environment}
                sed -i 's/MYSQL_CONTAINER_NAME=.*/MYSQL_CONTAINER_NAME=mysql-db/' .env.${environment}
                sed -i 's/ADMINER_CONTAINER_NAME=.*/ADMINER_CONTAINER_NAME=adminer/' .env.${environment}
                sed -i 's/PHP_DATA_PATH=.*/PHP_DATA_PATH=.\\/volumes\\/php_data/' .env.${environment}
                sed -i 's/PHP_LOGS_PATH=.*/PHP_LOGS_PATH=.\\/volumes\\/php_logs/' .env.${environment}
                sed -i 's/MYSQL_DATA_PATH=.*/MYSQL_DATA_PATH=.\\/volumes\\/mysql_data/' .env.${environment}
                sed -i 's/MYSQL_LOGS_PATH=.*/MYSQL_LOGS_PATH=.\\/volumes\\/mysql_logs/' .env.${environment}
                sed -i 's/NETWORK_SUBNET=.*/NETWORK_SUBNET=172.18.19.0\\/24/' .env.${environment}
            else
                sed -i 's/MYSQL_ROOT_PASSWORD=.*/MYSQL_ROOT_PASSWORD=test_rootpass/' .env.${environment}
                sed -i 's/MYSQL_DATABASE=.*/MYSQL_DATABASE=test_db/' .env.${environment}
                sed -i 's/MYSQL_USER=.*/MYSQL_USER=test_user/' .env.${environment}
                sed -i 's/MYSQL_PASSWORD=.*/MYSQL_PASSWORD=test_password/' .env.${environment}
                sed -i 's/PHP_CONTAINER_NAME=.*/PHP_CONTAINER_NAME=php-apache-test/' .env.${environment}
                sed -i 's/MYSQL_CONTAINER_NAME=.*/MYSQL_CONTAINER_NAME=mysql-db-test/' .env.${environment}
                sed -i 's/ADMINER_CONTAINER_NAME=.*/ADMINER_CONTAINER_NAME=adminer-test/' .env.${environment}
                sed -i 's/PHP_DATA_PATH=.*/PHP_DATA_PATH=.\\/volumes\\/test\\/php_data/' .env.${environment}
                sed -i 's/PHP_LOGS_PATH=.*/PHP_LOGS_PATH=.\\/volumes\\/test\\/php_logs/' .env.${environment}
                sed -i 's/MYSQL_DATA_PATH=.*/MYSQL_DATA_PATH=.\\/volumes\\/test\\/mysql_data/' .env.${environment}
                sed -i 's/MYSQL_LOGS_PATH=.*/MYSQL_LOGS_PATH=.\\/volumes\\/test\\/mysql_logs/' .env.${environment}
                sed -i 's/NETWORK_SUBNET=.*/NETWORK_SUBNET=172.19.20.0\\/24/' .env.${environment}
            fi
            
            sed -i 's/PHP_EXTERNAL_PORT=.*/PHP_EXTERNAL_PORT=${phpPort}/' .env.${environment}
            sed -i 's/MYSQL_EXTERNAL_PORT=.*/MYSQL_EXTERNAL_PORT=${mysqlPort}/' .env.${environment}
            sed -i 's/ADMINER_EXTERNAL_PORT=.*/ADMINER_EXTERNAL_PORT=${adminerPort}/' .env.${environment}
            sed -i 's/PHP_ENV=.*/PHP_ENV=${environment}/' .env.${environment}
            sed -i 's/MYSQL_APP_ENV=.*/MYSQL_APP_ENV=${environment}/' .env.${environment}
            sed -i 's/APP_DESCRIPTION=.*/APP_DESCRIPTION="PHP-Apache2 application with MySQL database"/' .env.${environment}
            sed -i 's/COMPOSE_PROJECT_NAME=.*/COMPOSE_PROJECT_NAME=php-mysql-app-${environment}/' .env.${environment}
            
            echo "Environment-specific .env file created for ${environment}:"
            cat .env.${environment}
        """
        
        sh """
            COMPOSE_PROJECT_NAME=${projectName} ${composeCmd} --env-file .env.${environment} down -v 2>/dev/null || true
        """
        
        sh """
            COMPOSE_PROJECT_NAME=${projectName} ${composeCmd} --env-file .env.${environment} up -d --build
        """
        
        echo "Waiting for deployment to stabilize..."
        sleep 60
        
        echo "Checking deployment health..."
        retry(15) {
            sleep(10)
            sh """
                COMPOSE_PROJECT_NAME=${projectName} ${composeCmd} --env-file .env.${environment} exec -T mysql-db${environment == 'production' ? '' : '-test'} mysqladmin ping -h mysql-db -u root --password="${environment == 'production' ? 'rootpass123!@#' : 'test_rootpass'}" --connect-timeout=5 || exit 1
                curl -f http://localhost:${phpPort}/ || exit 1
                curl -f http://localhost:${adminerPort}/ || exit 1
                echo "=== Service Status ==="
                COMPOSE_PROJECT_NAME=${projectName} ${composeCmd} --env-file .env.${environment} ps
            """
        }
        
        echo "Successfully deployed to ${environment}"
        echo "PHP Application: http://localhost:${phpPort}"
        echo "Adminer: http://localhost:${adminerPort}"
        echo "MySQL Connection: mysql -h127.0.0.1 -P${mysqlPort} -uroot -p${environment == 'production' ? 'rootpass123!@#' : 'test_rootpass'}"
        
    } catch (Exception e) {
        echo "Deployment to ${environment} failed: ${e.getMessage()}"
        sh """
            echo "=== Service Logs ==="
            COMPOSE_PROJECT_NAME=${projectName} ${composeCmd} --env-file .env.${environment} logs || echo "No logs available"
            echo "=== Service Status ==="
            COMPOSE_PROJECT_NAME=${projectName} ${composeCmd} --env-file .env.${environment} ps
            echo "=== Environment File ==="
            cat .env.${environment} 2>/dev/null || echo "Could not read .env.${environment}"
        """
        throw e
    }
}
