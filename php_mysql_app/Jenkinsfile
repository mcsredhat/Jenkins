pipeline {
    agent any

    environment {
        DOCKER_REGISTRY = 'https://index.docker.io/v1/'
        DOCKER_USERNAME = 'farajassulai'
        DOCKER_REPO_PHP = 'php-apache'
        DOCKER_REPO_MYSQL = 'mysql-db'
        PHP_IMAGE_NAME = "${DOCKER_USERNAME}/${DOCKER_REPO_PHP}"
        MYSQL_IMAGE_NAME = "${DOCKER_USERNAME}/${DOCKER_REPO_MYSQL}"
        BUILD_TAG = "${env.BUILD_NUMBER}-${env.GIT_COMMIT?.take(7) ?: 'unknown'}"
        GITHUB_REPO = 'https://github.com/mcsredhat/Jenkins'
        
        // Application directory
        APP_DIR = 'php_mysql_app'
        
        // Pipeline control flags
        SKIP_SECURITY_SCAN = 'false'
        ENABLE_DOCKER_PUSH = 'true'
        ENABLE_STAGING_DEPLOY = 'true'
        ENABLE_PRODUCTION_DEPLOY = 'true'
        EMAIL_CONFIGURED = 'false'
    }

    stages {
        stage('Checkout') {
            steps {
                echo "Checking out code from GitHub repository..."
                checkout scm

                script {
                    dir(APP_DIR) {
                        echo "Current branch: ${env.BRANCH_NAME ?: 'main'}"
                        echo "Git commit: ${env.GIT_COMMIT ?: 'unknown'}"
                        echo "Repository URL: ${GITHUB_REPO}"
                        echo "Working directory: ${pwd()}"
                        
                        // Show current working directory and contents
                         sh "pwd && ls -la"
                        
                        echo "Checking Docker environment..."
                        sh """
                            docker --version || echo "Docker not found"
                            docker compose version 2>/dev/null && echo "Docker Compose (plugin) available" || echo "Docker Compose plugin not found"
                            docker-compose --version 2>/dev/null && echo "Docker Compose (standalone) available" || echo "Docker Compose standalone not found"
                        """
                        
                        echo "Checking project structure..."
                        sh """
                            ls -la docker-compose.yml || echo ' docker-compose.yml files not found'
                            ls -la .env  || echo '.env files not found'
                            ls -la Jenkinsfile || echo 'Jenkinsfile files not found'
                            ls -la ./mysql/ || echo ' /mysql  directories not found'
                            ls -la ./mysql/config || echo ' /mysql/config  directories not found'
                            ls -la ./php-apache/ || echo ' /php-apache/ directories not found'
                            ls -la ./php-apache/src || echo ' /src directories not found'
                            ls -la ./php-apache/apache-config || echo ' apache-config project directories not found'
                            ls -la ./php-apache/php-config || echo ' php-config project directories not found'
                            ls -la docker-compose.yml .env || echo 'Docker Compose files not found'
                            ls -la ./mysql/Dockerfile || echo 'Some mysql Dockerfiles not found'
                            ls -la ./mysql/.env || echo 'Some env files not found'
                            ls -la ./php-apache/Dockerfile || echo 'Some PHP Dockerfiles not found'
                            ls -la ./php-apache/.env || echo 'Some env files not found'
                        """
                    }
                }
            }
        }

        stage('Load Environment Configuration') {
            steps {
                echo "Loading port configuration from .env file..."
                script {
                    dir(APP_DIR) {
                        // Load environment variables from .env file
                        def envVars = [:]
                        if (fileExists('.env')) {
                            def envContent = readFile('.env')
                            envContent.split('\n').each { line ->
                                line = line.trim()
                                if (line && !line.startsWith('#') && line.contains('=')) {
                                    def parts = line.split('=', 2)
                                    if (parts.length == 2) {
                                        envVars[parts[0].trim()] = parts[1].trim()
                                    }
                                }
                            }
                            
                            // Set environment variables from .env file
                            env.COMPOSE_PROJECT_NAME = envVars['COMPOSE_PROJECT_NAME'] ?: 'php-mysql-app'
                            env.PHP_EXTERNAL_PORT = envVars['PHP_EXTERNAL_PORT'] ?: '8088'
                            env.MYSQL_EXTERNAL_PORT = envVars['MYSQL_EXTERNAL_PORT'] ?: '3306'
                            env.ADMINER_EXTERNAL_PORT = envVars['ADMINER_EXTERNAL_PORT'] ?: '8082'
                            env.TEST_PHP_PORT = envVars['TEST_PHP_PORT'] ?: '8089'
                            env.TEST_MYSQL_PORT = envVars['TEST_MYSQL_PORT'] ?: '3366'
                            env.TEST_ADMINER_PORT = envVars['TEST_ADMINER_PORT'] ?: '8083'
                            env.STAGING_PHP_PORT = envVars['STAGING_PHP_PORT'] ?: '8090'
                            env.STAGING_MYSQL_PORT = envVars['STAGING_MYSQL_PORT'] ?: '3307'
                            env.STAGING_ADMINER_PORT = envVars['STAGING_ADMINER_PORT'] ?: '8084'
                            env.PRODUCTION_PHP_PORT = envVars['PRODUCTION_PHP_PORT'] ?: '8091'
                            env.PRODUCTION_MYSQL_PORT = envVars['PRODUCTION_MYSQL_PORT'] ?: '3308'
                            env.PRODUCTION_ADMINER_PORT = envVars['PRODUCTION_ADMINER_PORT'] ?: '8085'
                            
                            // Load MySQL credentials for health checks
                            env.MYSQL_ROOT_PASSWORD = envVars['MYSQL_ROOT_PASSWORD'] ?: 'SecureRootPass2024!'
                            env.MYSQL_HEALTHCHECK_USER = envVars['MYSQL_HEALTHCHECK_USER'] ?: 'healthcheck'
                            env.MYSQL_HEALTHCHECK_PASSWORD = envVars['MYSQL_HEALTHCHECK_PASSWORD'] ?: 'SecureHealthPass2024!'
                            
                            echo "Loaded environment configuration successfully"
                        } else {
                            error("No .env file found in ${APP_DIR}")
                        }
                        
                        // Display loaded port configuration
                        echo """
                        ===========================================
                        LOADED PORT CONFIGURATION
                        ===========================================
                        Default Environment:
                          - PHP-Apache: ${env.PHP_EXTERNAL_PORT}
                          - MySQL: ${env.MYSQL_EXTERNAL_PORT}
                          - Adminer: ${env.ADMINER_EXTERNAL_PORT}
                        
                        Testing Environment:
                          - PHP-Apache: ${env.TEST_PHP_PORT}
                          - MySQL: ${env.TEST_MYSQL_PORT}
                          - Adminer: ${env.TEST_ADMINER_PORT}
                        
                        Staging Environment:
                          - PHP-Apache: ${env.STAGING_PHP_PORT}
                          - MySQL: ${env.STAGING_MYSQL_PORT}
                          - Adminer: ${env.STAGING_ADMINER_PORT}
                        
                        Production Environment:
                          - PHP-Apache: ${env.PRODUCTION_PHP_PORT}
                          - MySQL: ${env.PRODUCTION_MYSQL_PORT}
                          - Adminer: ${env.PRODUCTION_ADMINER_PORT}
                        ===========================================
                        """
                    }
                }
            }
        }

        stage('Setup Environment') {
            steps {
                echo "Setting up environment and creating required directories..."
                script {
                    dir(APP_DIR) {
                        sh """
                            # Create volume directories as specified in .env
                            mkdir -p ./volumes/{php_data,php_logs,mysql_data,mysql_logs} || true
                            # Only change permissions if we have the rights
                            chmod 755 ./volumes/* || true
                            # Verify directories exist
                            ls -la ./volumes/
                            
                            # Clean up any existing containers
                            docker compose down -v 2>/dev/null || docker-compose down -v 2>/dev/null || echo "No compose services to stop"
                            docker container prune -f || true
                            
                            # Remove any test containers
                            docker stop test-php-mysql-${env.BUILD_NUMBER} || true
                            docker rm test-php-mysql-${env.BUILD_NUMBER} || true
                        """
                    }
                }
            }
        }

        stage('Build') {
            steps {
                echo "Building Docker images using Docker Compose..."
                script {
                    dir(APP_DIR) {
                        try {
                            // Determine which compose command to use
                            def composeCmd = sh(
                                script: "docker compose version >/dev/null 2>&1 && echo 'docker compose' || echo 'docker-compose'",
                                returnStdout: true
                            ).trim()
                            echo "Using compose command: ${composeCmd}"
                            
                            // Build all services
                            sh """
                                ${composeCmd} build 2>&1 | tee build.log
                                if [ \${PIPESTATUS[0]} -ne 0 ]; then
                                    echo "Docker Compose build failed, displaying build log:"
                                    cat build.log
                                    exit 1
                                fi
                            """
                            
                            // Tag images with build-specific tags using the actual compose project name
                            sh """
                                # Get the actual image names created by docker-compose
                                PHP_IMAGE=\$(docker images --format "table {{.Repository}}:{{.Tag}}" | grep "${env.COMPOSE_PROJECT_NAME}" | grep -E "(php|apache)" | head -1 | tr -s ' ' | cut -d' ' -f1)
                                MYSQL_IMAGE=\$(docker images --format "table {{.Repository}}:{{.Tag}}" | grep "${env.COMPOSE_PROJECT_NAME}" | grep mysql | head -1 | tr -s ' ' | cut -d' ' -f1)
                                
                                echo "Found images:"
                                echo "PHP Image: \$PHP_IMAGE"
                                echo "MySQL Image: \$MYSQL_IMAGE"
                                
                                # Tag PHP image
                                if [ ! -z "\$PHP_IMAGE" ] && [ "\$PHP_IMAGE" != " " ]; then
                                    docker tag \$PHP_IMAGE ${PHP_IMAGE_NAME}:${BUILD_TAG}
                                    docker tag \$PHP_IMAGE ${PHP_IMAGE_NAME}:latest
                                    echo "Tagged PHP image successfully"
                                else
                                    echo "WARNING: PHP image not found for tagging"
                                fi
                                
                                # Tag MySQL image
                                if [ ! -z "\$MYSQL_IMAGE" ] && [ "\$MYSQL_IMAGE" != " " ]; then
                                    docker tag \$MYSQL_IMAGE ${MYSQL_IMAGE_NAME}:${BUILD_TAG}
                                    docker tag \$MYSQL_IMAGE ${MYSQL_IMAGE_NAME}:latest
                                    echo "Tagged MySQL image successfully"
                                else
                                    echo "WARNING: MySQL image not found for tagging"
                                fi
                                
                                echo "Images built and tagged successfully"
                                docker images | grep -E "(${DOCKER_USERNAME}|${env.COMPOSE_PROJECT_NAME})"
                            """
                            
                        } catch (Exception e) {
                            echo "Build failed: ${e.getMessage()}"
                            sh "cat build.log || echo 'No build log available'"
                            throw e
                        }
                    }
                }
            }
        }

        stage('Test') {
            steps {
                echo "Running integration tests..."
                script {
                    dir(APP_DIR) {
                        try {
                            // Create test environment file
                            sh """
                                cp .env .env.test
                                sed -i 's/PHP_EXTERNAL_PORT=${env.PHP_EXTERNAL_PORT}/PHP_EXTERNAL_PORT=${env.TEST_PHP_PORT}/' .env.test
                                sed -i 's/MYSQL_EXTERNAL_PORT=${env.MYSQL_EXTERNAL_PORT}/MYSQL_EXTERNAL_PORT=${env.TEST_MYSQL_PORT}/' .env.test
                                sed -i 's/ADMINER_EXTERNAL_PORT=${env.ADMINER_EXTERNAL_PORT}/ADMINER_EXTERNAL_PORT=${env.TEST_ADMINER_PORT}/' .env.test
                                sed -i 's/COMPOSE_PROJECT_NAME=${env.COMPOSE_PROJECT_NAME}/COMPOSE_PROJECT_NAME=test-${env.COMPOSE_PROJECT_NAME}-${env.BUILD_NUMBER}/' .env.test
                                sed -i 's/PHP_ENV=production/PHP_ENV=testing/' .env.test
                                sed -i 's/MYSQL_APP_ENV=production/MYSQL_APP_ENV=testing/' .env.test
                            """
                            
                            def composeCmd = sh(
                                script: "docker compose version >/dev/null 2>&1 && echo 'docker compose' || echo 'docker-compose'",
                                returnStdout: true
                            ).trim()
                            
                            // Start test environment
                            sh """
                                ${composeCmd} --env-file .env.test up -d --build
                                echo "Waiting for services to start..."
                                sleep 30
                            """
                            
                            // Wait for MySQL to be ready using correct credentials
                            echo "Waiting for MySQL to be ready..."
                            retry(15) {
                                sleep(10)
                                sh """
                                    ${composeCmd} --env-file .env.test exec -T mysql-db mysqladmin ping -h localhost -u ${env.MYSQL_HEALTHCHECK_USER} --password="${env.MYSQL_HEALTHCHECK_PASSWORD}" || exit 1
                                """
                            }
                            
                            // Wait for PHP-Apache to be ready with health check endpoint
                            echo "Waiting for PHP-Apache to be ready..."
                            retry(10) {
                                sleep(10)
                                sh """
                                    # Try health endpoint first, then fallback to root
                                    curl -f http://localhost:${env.TEST_PHP_PORT}/health || curl -f http://localhost:${env.TEST_PHP_PORT} || exit 1
                                """
                            }
                            
                            // Run tests
                            echo "Running application tests..."
                            sh """
                                # Test MySQL connectivity with healthcheck user
                                ${composeCmd} --env-file .env.test exec -T mysql-db mysql -u${env.MYSQL_HEALTHCHECK_USER} -p${env.MYSQL_HEALTHCHECK_PASSWORD} -e "SHOW DATABASES;"
                                
                                # Test PHP-Apache connectivity
                                curl -f http://localhost:${env.TEST_PHP_PORT}/health -o /dev/null -s -w "Health Check HTTP Status: %{http_code}\\n" || \
                                curl -f http://localhost:${env.TEST_PHP_PORT} -o /dev/null -s -w "Root HTTP Status: %{http_code}\\n"
                                
                                # Test Adminer connectivity
                                curl -f http://localhost:${env.TEST_ADMINER_PORT} -o /dev/null -s -w "Adminer HTTP Status: %{http_code}\\n"
                                
                                # Test database connection from PHP using environment variables from docker-compose
                                ${composeCmd} --env-file .env.test exec -T php-apache php -r "
                                    \\$host = getenv('DB_HOST') ?: 'mysql-db';
                                    \\$port = getenv('DB_PORT') ?: '3306';
                                    \\$dbname = getenv('DB_NAME') ?: 'php_mysql_app';
                                    \\$username = getenv('DB_USER') ?: 'appuser';
                                    \\$password = getenv('DB_PASSWORD') ?: 'SecureUserPass2024!';
                                    
                                    echo \\\"Attempting connection with: host=\\$host, port=\\$port, dbname=\\$dbname, user=\\$username\\\\n\\\";
                                    
                                    try {
                                        \\$dsn = \\\"mysql:host=\\$host;port=\\$port;dbname=\\$dbname\\\";
                                        \\$pdo = new PDO(\\$dsn, \\$username, \\$password, [
                                            PDO::ATTR_ERRMODE => PDO::ERRMODE_EXCEPTION,
                                            PDO::ATTR_TIMEOUT => 5
                                        ]);
                                        echo \\\"✅ Database connection successful!\\\\n\\\";
                                        
                                        // Test a simple query
                                        \\$stmt = \\$pdo->query('SELECT VERSION() as version');
                                        \\$result = \\$stmt->fetch();
                                        echo \\\"MySQL Version: \\\" . \\$result['version'] . \\\"\\\\n\\\";
                                        
                                    } catch (PDOException \\$e) {
                                        echo \\\"❌ Database connection failed: \\\" . \\$e->getMessage() . \\\"\\\\n\\\";
                                        exit(1);
                                    }
                                "
                                
                                # Test container communication
                                echo "Testing container network connectivity..."
                                ${composeCmd} --env-file .env.test exec -T php-apache ping -c 3 mysql-db || echo "Ping test failed but containers might still communicate"
                            """
                            
                            echo "All tests passed!"
                            
                        } catch (Exception e) {
                            echo "Tests failed: ${e.getMessage()}"
                            sh """
                                echo "=== Service Status ==="
                                ${composeCmd} --env-file .env.test ps || echo "Could not retrieve service status"
                                
                                echo "=== Service Logs ==="
                                ${composeCmd} --env-file .env.test logs --tail=50 || echo "Could not retrieve logs"
                                
                                echo "=== Network Information ==="
                                docker network ls | grep test || echo "No test networks found"
                                
                                echo "=== Container Information ==="
                                docker ps | grep test || echo "No test containers found"
                            """
                            throw e
                        } finally {
                            // Cleanup test environment
                            sh """
                                ${composeCmd} --env-file .env.test down -v || true
                                rm -f .env.test || true
                            """
                        }
                    }
                }
            }
        }

        stage('Security Scan') {
            when {
                environment name: 'SKIP_SECURITY_SCAN', value: 'false'
            }
            steps {
                echo "Running security scans with Trivy..."
                script {
                    dir(APP_DIR) {
                        try {
                            def trivyAvailable = sh(
                                script: "docker run --rm aquasec/trivy:latest --version",
                                returnStatus: true
                            )
                            if (trivyAvailable != 0) {
                                echo "Trivy not available, skipping security scan"
                                currentBuild.result = 'UNSTABLE'
                                return
                            }
                            
                            // Scan PHP image
                            echo "Scanning PHP image for vulnerabilities..."
                            sh """
                                docker run --rm -v /var/run/docker.sock:/var/run/docker.sock \
                                aquasec/trivy:latest image \
                                --format table \
                                --severity LOW,MEDIUM,HIGH,CRITICAL \
                                ${PHP_IMAGE_NAME}:${BUILD_TAG} || true
                            """
                            
                            // Scan MySQL image
                            echo "Scanning MySQL image for vulnerabilities..."
                            sh """
                                docker run --rm -v /var/run/docker.sock:/var/run/docker.sock \
                                aquasec/trivy:latest image \
                                --format table \
                                --severity LOW,MEDIUM,HIGH,CRITICAL \
                                ${MYSQL_IMAGE_NAME}:${BUILD_TAG} || true
                            """
                            
                            // Check for critical vulnerabilities
                            def criticalScanResult = sh(
                                script: """
                                    docker run --rm -v /var/run/docker.sock:/var/run/docker.sock \
                                    aquasec/trivy:latest image \
                                    --exit-code 1 --severity CRITICAL \
                                    --format table \
                                    ${PHP_IMAGE_NAME}:${BUILD_TAG} ${MYSQL_IMAGE_NAME}:${BUILD_TAG} || true
                                """,
                                returnStatus: true
                            )
                            
                            if (criticalScanResult == 0) {
                                echo "No CRITICAL vulnerabilities found"
                            } else {
                                echo "CRITICAL vulnerabilities found - marking build as unstable"
                                currentBuild.result = 'UNSTABLE'
                            }
                            
                        } catch (Exception e) {
                            echo "Security scan failed: ${e.getMessage()}"
                            currentBuild.result = 'UNSTABLE'
                        }
                    }
                }
            }
        }

        stage('Push to Docker Hub') {
            when {
                anyOf {
                    branch 'main'
                    branch 'develop'
                    environment name: 'ENABLE_DOCKER_PUSH', value: 'true'
                }
            }
            steps {
                echo "Pushing images to Docker Hub..."
                script {
                    dir(APP_DIR) {
                        try {
                            docker.withRegistry("${DOCKER_REGISTRY}", 'dockerhub-credentials') {
                                // Push PHP image
                                def phpImage = docker.image("${PHP_IMAGE_NAME}:${BUILD_TAG}")
                                phpImage.push()
                                phpImage.push("latest")
                                
                                // Push MySQL image
                                def mysqlImage = docker.image("${MYSQL_IMAGE_NAME}:${BUILD_TAG}")
                                mysqlImage.push()
                                mysqlImage.push("latest")
                                
                                // Branch-specific tags
                                if (env.BRANCH_NAME == 'main') {
                                    phpImage.push("production")
                                    mysqlImage.push("production")
                                } else if (env.BRANCH_NAME == 'develop') {
                                    phpImage.push("staging")
                                    mysqlImage.push("staging")
                                }
                                
                                echo "Images pushed successfully to Docker Hub"
                            }
                        } catch (Exception e) {
                            echo "Docker Hub push failed: ${e.getMessage()}"
                            echo "Attempting push without registry authentication..."
                            sh """
                                docker push ${PHP_IMAGE_NAME}:${BUILD_TAG} || echo "PHP image push failed"
                                docker push ${PHP_IMAGE_NAME}:latest || echo "PHP latest tag push failed"
                                docker push ${MYSQL_IMAGE_NAME}:${BUILD_TAG} || echo "MySQL image push failed"
                                docker push ${MYSQL_IMAGE_NAME}:latest || echo "MySQL latest tag push failed"
                            """
                            currentBuild.result = 'UNSTABLE'
                        }
                    }
                }
            }
        }

        stage('Deploy to Staging') {
            when {
                anyOf {
                    branch 'develop'
                    environment name: 'ENABLE_STAGING_DEPLOY', value: 'true'
                }
            }
            steps {
                echo "Deploying to staging environment..."
                script {
                    dir(APP_DIR) {
                        deployToEnvironment('staging', env.STAGING_PHP_PORT, env.STAGING_MYSQL_PORT, env.STAGING_ADMINER_PORT)
                    }
                }
            }
        }

        stage('Deploy to Production') {
            when {
                anyOf {
                    branch 'main'
                    environment name: 'ENABLE_PRODUCTION_DEPLOY', value: 'true'
                }
            }
            steps {
                script {
                    dir(APP_DIR) {
                        if (env.SKIP_PRODUCTION_APPROVAL != 'true') {
                            try {
                                timeout(time: 5, unit: 'MINUTES') {
                                    input message: 'Deploy to production?', ok: 'Deploy'
                                }
                            } catch (Exception e) {
                                echo "Production deployment approval timeout or skipped"
                                return
                            }
                        }
                        echo "Deploying to production environment..."
                        deployToEnvironment('production', env.PRODUCTION_PHP_PORT, env.PRODUCTION_MYSQL_PORT, env.PRODUCTION_ADMINER_PORT)
                    }
                }
            }
        }
    }

    post {
        always {
            echo "Cleaning up..."
            script {
                dir(APP_DIR) {
                    sh """
                        # Clean up any test environments
                        docker compose --env-file .env.test down -v 2>/dev/null || true
                        docker compose --env-file .env.staging down 2>/dev/null || true
                        
                        # System cleanup
                        docker system prune -f --filter "until=24h"
                        
                        # Remove temporary files
                        rm -f .env.test .env.staging .env.production || true
                    """
                }
            }
        }

        success {
            echo "Pipeline completed successfully!"
            script {
                if (env.EMAIL_CONFIGURED == 'true') {
                    try {
                        emailext(
                            subject: "PHP-MySQL App Build Success: ${env.JOB_NAME} #${env.BUILD_NUMBER}",
                            body: """
                                PHP-MySQL application build succeeded!

                                Job: ${env.JOB_NAME}
                                Build Number: ${env.BUILD_NUMBER}
                                Branch: ${env.BRANCH_NAME ?: 'main'}
                                Application Directory: ${APP_DIR}
                                PHP Image: ${PHP_IMAGE_NAME}:${BUILD_TAG}
                                MySQL Image: ${MYSQL_IMAGE_NAME}:${BUILD_TAG}

                                GitHub: ${GITHUB_REPO}
                                Build URL: ${env.BUILD_URL}

                                Services:
                                - PHP-Apache: http://localhost:${env.PHP_EXTERNAL_PORT}
                                - Adminer: http://localhost:${env.ADMINER_EXTERNAL_PORT}
                                - MySQL: localhost:${env.MYSQL_EXTERNAL_PORT}
                            """,
                            recipientProviders: [developers()]
                        )
                    } catch (Exception e) {
                        echo "Failed to send success email: ${e.getMessage()}"
                    }
                }
            }
        }

        failure {
            echo "Pipeline failed!"
            script {
                if (env.EMAIL_CONFIGURED == 'true') {
                    try {
                        emailext(
                            subject: "PHP-MySQL App Build Failed: ${env.JOB_NAME} #${env.BUILD_NUMBER}",
                            body: """
                                PHP-MySQL application build failed!

                                Job: ${env.JOB_NAME}
                                Branch: ${env.BRANCH_NAME ?: 'main'}
                                Application Directory: ${APP_DIR}
                                Build URL: ${env.BUILD_URL}

                                Please check the console output for details:
                                ${env.BUILD_URL}console
                            """,
                            recipientProviders: [developers(), requestor()]
                        )
                    } catch (Exception e) {
                        echo "Failed to send failure email: ${e.getMessage()}"
                    }
                }
            }
        }

        unstable {
            echo "Pipeline completed with warnings."
        }
    }
}

def deployToEnvironment(environment, phpPort, mysqlPort, adminerPort) {
    def deploymentName = "php-mysql-app-${environment}"
    try {
        echo "Deploying PHP-MySQL application to ${environment}"
        echo "Ports - PHP: ${phpPort}, MySQL: ${mysqlPort}, Adminer: ${adminerPort}"
        
        // Create deployment-specific environment file
        sh """
            cp .env .env.${environment}
            sed -i 's/PHP_EXTERNAL_PORT=${env.PHP_EXTERNAL_PORT}/PHP_EXTERNAL_PORT=${phpPort}/' .env.${environment}
            sed -i 's/MYSQL_EXTERNAL_PORT=${env.MYSQL_EXTERNAL_PORT}/MYSQL_EXTERNAL_PORT=${mysqlPort}/' .env.${environment}
            sed -i 's/ADMINER_EXTERNAL_PORT=${env.ADMINER_EXTERNAL_PORT}/ADMINER_EXTERNAL_PORT=${adminerPort}/' .env.${environment}
            sed -i 's/COMPOSE_PROJECT_NAME=${env.COMPOSE_PROJECT_NAME}/COMPOSE_PROJECT_NAME=${deploymentName}/' .env.${environment}
            sed -i 's/PHP_ENV=production/PHP_ENV=${environment}/' .env.${environment}
            sed -i 's/MYSQL_APP_ENV=production/MYSQL_APP_ENV=${environment}/' .env.${environment}
        """
        
        def composeCmd = sh(
            script: "docker compose version >/dev/null 2>&1 && echo 'docker compose' || echo 'docker-compose'",
            returnStdout: true
        ).trim()
        
        // Stop existing deployment
        sh """
            ${composeCmd} --env-file .env.${environment} down -v || true
        """
        
        // Deploy new version
        sh """
            ${composeCmd} --env-file .env.${environment} up -d --build
        """
        
        echo "Waiting for deployment to stabilize..."
        sleep 60
        
        // Health checks with proper credentials
        echo "Performing health checks..."
        retry(15) {
            sleep(10)
            sh """
                # Check PHP-Apache
                curl -f http://localhost:${phpPort}/health -o /dev/null -s || curl -f http://localhost:${phpPort} -o /dev/null -s || exit 1
                
                # Check Adminer
                curl -f http://localhost:${adminerPort} -o /dev/null -s || exit 1
                
                # Check MySQL with healthcheck user
                ${composeCmd} --env-file .env.${environment} exec -T mysql-db mysqladmin ping -h localhost -u ${env.MYSQL_HEALTHCHECK_USER} --password="${env.MYSQL_HEALTHCHECK_PASSWORD}" || exit 1
            """
        }
        
        echo "Successfully deployed to ${environment}"
        echo "Access URLs:"
        echo "  - PHP Application: http://localhost:${phpPort}"
        echo "  - Adminer (DB Admin): http://localhost:${adminerPort}"
        echo "  - MySQL: localhost:${mysqlPort}"
        
        // Show running containers
        sh "${composeCmd} --env-file .env.${environment} ps"
        
    } catch (Exception e) {
        echo "Deployment to ${environment} failed: ${e.getMessage()}"
        sh """
            echo "=== Container Status ==="
            ${composeCmd} --env-file .env.${environment} ps || echo "No containers running"
            
            echo "=== Container Logs ==="
            ${composeCmd} --env-file .env.${environment} logs --tail=50 || echo "No logs available"
            
            echo "=== System Information ==="
            docker system df || echo "Could not get system info"
        """
        throw e
    } finally {
        sh "rm -f .env.${environment} || true"
    }
}
