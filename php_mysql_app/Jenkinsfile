pipeline {
    agent any

    environment {
        DOCKER_REGISTRY = 'https://index.docker.io/v1/'
        DOCKER_USERNAME = 'farajassulai'
        DOCKER_REPO = 'php-mysql-app'
        IMAGE_NAME = "${DOCKER_USERNAME}/${DOCKER_REPO}"
        BUILD_TAG = "${env.BUILD_NUMBER}-${env.GIT_COMMIT?.take(7) ?: 'unknown'}"
        CONTAINER_NAME = "php-mysql-project"
        TEST_CONTAINER_NAME = "php-mysql-test-${env.BUILD_NUMBER}"
        GITHUB_REPO = 'https://github.com/mcsredhat/Jenkins'
        APP_DIR = "php_mysql_app"
        SKIP_SECURITY_SCAN = 'false'
        ENABLE_DOCKER_PUSH = 'true'
        ENABLE_STAGING_DEPLOY = 'true'
        ENABLE_PRODUCTION_DEPLOY = 'true'
        FORCE_BRANCH_MAIN = 'true'
        FORCE_BRANCH_DEVELOP = 'false'
        EMAIL_CONFIGURED = 'false'
        COMPOSE_PROJECT_NAME = "php-mysql-app-${env.BUILD_NUMBER}"
        TEST_COMPOSE_PROJECT_NAME = "php-mysql-test-${env.BUILD_NUMBER}"
    }

    stages {
        stage('Checkout') {
            steps {
                echo "Checking out code from GitHub repository..."
                checkout scm

                script {
                    echo "Current branch: ${env.BRANCH_NAME ?: 'main'}"
                    echo "Git commit: ${env.GIT_COMMIT ?: 'unknown'}"
                    echo "Repository URL: ${GITHUB_REPO}"
                    echo "Working in directory: ${pwd()}"
                    echo "Application directory: ${APP_DIR}"
                    sh "ls -la"
                    echo "Checking Docker environment..."
                    sh """
                        docker --version || echo "Docker not found"
                        docker compose version 2>/dev/null && echo "Docker Compose (plugin) available" || echo "Docker Compose plugin not found"
                        docker-compose --version 2>/dev/null && echo "Docker Compose (standalone) available" || echo "Docker Compose standalone not found"
                    """
                    echo "Checking project structure..."
                    sh """
                        ls -la ${APP_DIR}/mysql/ ${APP_DIR}/mysql/config  ${APP_DIR}/php-apache/ ${APP_DIR/}/php-apache/src ${APP_DIR}/php-apache/apache-config ${APP_DIR}/php-apache/php-config || echo 'Project directories not found'
                        ls -la docker-compose.yml .env || echo 'Docker Compose files not found'
                        ls -la ${APP_DIR}/mysql/Dockerfile ${APP_DIR/}/php-apache/Dockerfile || echo 'Dockerfiles not found'
                    """
                }
            }
        }

        stage('Setup Environment') {
            steps {
                echo "Setting up environment..."
                script {
                    sh """
                        # Create necessary directories as specified in .env
                        mkdir -p php-apache/src mysql ./volumes/php_data ./volumes/php_logs ./volumes/mysql_data ./volumes/mysql_logs
                        chmod 755 ./volumes ./volumes/php_data ./volumes/php_logs ./volumes/mysql_data ./volumes/mysql_logs
                        
                        # Stop any existing containers
                        docker compose -p ${COMPOSE_PROJECT_NAME} down -v 2>/dev/null || docker-compose -p ${COMPOSE_PROJECT_NAME} down -v 2>/dev/null || echo "No compose services to stop"
                        docker compose -p ${TEST_COMPOSE_PROJECT_NAME} down -v 2>/dev/null || docker-compose -p ${TEST_COMPOSE_PROJECT_NAME} down -v 2>/dev/null || echo "No test compose services to stop"
                        
                        # Clean up any orphaned containers
                        docker container prune -f || true
                        docker volume prune -f || true
                    """
                }
            }
        }

        stage('Build') {
            steps {
                echo "Building Docker images with Docker Compose..."
                script {
                    try {
                        def composeCmd = sh(
                            script: "docker compose version >/dev/null 2>&1 && echo 'docker compose' || echo 'docker-compose'",
                            returnStdout: true
                        ).trim()
                        echo "Using compose command: ${composeCmd}"
                        
                        // Validate .env file exists and has required variables
                        sh """
                            if [ ! -f .env ]; then
                                echo "Error: .env file not found"
                                exit 1
                            fi
                            
                            # Check for required environment variables
                            grep -q "MYSQL_ROOT_PASSWORD=" .env || (echo "Error: MYSQL_ROOT_PASSWORD not found in .env" && exit 1)
                            grep -q "MYSQL_DATABASE=" .env || (echo "Error: MYSQL_DATABASE not found in .env" && exit 1)
                            grep -q "PHP_VERSION=" .env || (echo "Error: PHP_VERSION not found in .env" && exit 1)
                            
                            echo "Environment file validation passed"
                        """
                        
                        sh """
                            # Build with proper project name
                            COMPOSE_PROJECT_NAME=${COMPOSE_PROJECT_NAME} ${composeCmd} build --no-cache 2>&1 | tee build.log
                            if [ \${PIPESTATUS[0]} -ne 0 ]; then
                                echo "Docker Compose build failed, displaying build log:"
                                cat build.log
                                exit 1
                            fi
                        """
                        
                        // Tag the built images
                        sh """
                            # Get the PHP application image
                            PHP_IMAGE=\$(docker images --format "table {{.Repository}}:{{.Tag}}" | grep "${COMPOSE_PROJECT_NAME}" | grep php | head -1 | awk '{print \$1}')
                            if [ ! -z "\$PHP_IMAGE" ]; then
                                docker tag \$PHP_IMAGE ${IMAGE_NAME}:${BUILD_TAG}
                                docker tag \$PHP_IMAGE ${IMAGE_NAME}:latest
                                echo "Tagged PHP image: \$PHP_IMAGE -> ${IMAGE_NAME}:${BUILD_TAG}"
                            else
                                echo "Warning: Could not find PHP image to tag"
                                echo "Available images:"
                                docker images | grep "${COMPOSE_PROJECT_NAME}"
                            fi
                        """
                        
                        echo "Images built successfully with project name: ${COMPOSE_PROJECT_NAME}"
                    } catch (Exception e) {
                        echo "Build failed: ${e.getMessage()}"
                        sh "cat build.log || echo 'No build log available'"
                        throw e
                    }
                }
            }
        }

        stage('Test') {
            steps {
                echo "Running containerized tests with Docker Compose..."
                script {
                    try {
                        def composeCmd = sh(
                            script: "docker compose version >/dev/null 2>&1 && echo 'docker compose' || echo 'docker-compose'",
                            returnStdout: true
                        ).trim()
                        
                        // Create test environment file based on main .env
                        sh """
                            # Create test environment file based on main .env
                            cp .env .env.test
                            
                            # Override specific values for testing
                            sed -i 's/MYSQL_ROOT_PASSWORD=.*/MYSQL_ROOT_PASSWORD=test_rootpass/' .env.test
                            sed -i 's/MYSQL_DATABASE=.*/MYSQL_DATABASE=test_db/' .env.test
                            sed -i 's/MYSQL_USER=.*/MYSQL_USER=test_user/' .env.test
                            sed -i 's/MYSQL_PASSWORD=.*/MYSQL_PASSWORD=test_password/' .env.test
                            sed -i 's/PHP_EXTERNAL_PORT=.*/PHP_EXTERNAL_PORT=8089/' .env.test
                            sed -i 's/MYSQL_EXTERNAL_PORT=.*/MYSQL_EXTERNAL_PORT=3307/' .env.test
                            sed -i 's/ADMINER_EXTERNAL_PORT=.*/ADMINER_EXTERNAL_PORT=8083/' .env.test
                            
                            echo "Test environment file created"
                        """
                        
                        // Start services for testing
                        sh """
                            COMPOSE_PROJECT_NAME=${TEST_COMPOSE_PROJECT_NAME} ${composeCmd} --env-file .env.test up -d --build
                        """
                        
                        echo "Waiting for services to start..."
                        sleep 15
                        
                        // Wait for MySQL to be ready
                        retry(10) {
                            sleep(02)
                            sh """
                                # Check if MySQL is ready
                                COMPOSE_PROJECT_NAME=${TEST_COMPOSE_PROJECT_NAME} ${composeCmd} --env-file .env.test exec -T mysql-db mysqladmin ping -h 127.0.0.1 -u root --password=test_rootpass --connect-timeout=5
                            """
                        }
                        
                        echo "MySQL is ready! Running tests..."
                        
                        // Test MySQL functionality
                        sh """
                            # Test MySQL connection and basic operations
                            COMPOSE_PROJECT_NAME=${TEST_COMPOSE_PROJECT_NAME} ${composeCmd} --env-file .env.test exec -T mysql-db mysql -uroot -ptest_rootpass -h 127.0.0.1 -e "SHOW DATABASES;"
                            COMPOSE_PROJECT_NAME=${TEST_COMPOSE_PROJECT_NAME} ${composeCmd} --env-file .env.test exec -T mysql-db mysql -uroot -ptest_rootpass -h 127.0.0.1 -e "USE test_db; CREATE TABLE IF NOT EXISTS test_table (id INT PRIMARY KEY, name VARCHAR(50));"
                            COMPOSE_PROJECT_NAME=${TEST_COMPOSE_PROJECT_NAME} ${composeCmd} --env-file .env.test exec -T mysql-db mysql -uroot -ptest_rootpass -h 127.0.0.1 -e "USE test_db; INSERT IGNORE INTO test_table (id, name) VALUES (1, 'test');"
                            COMPOSE_PROJECT_NAME=${TEST_COMPOSE_PROJECT_NAME} ${composeCmd} --env-file .env.test exec -T mysql-db mysql -uroot -ptest_rootpass -h 127.0.0.1 -e "USE test_db; SELECT * FROM test_table;"
                            COMPOSE_PROJECT_NAME=${TEST_COMPOSE_PROJECT_NAME} ${composeCmd} --env-file .env.test exec -T mysql-db mysql -utest_user -ptest_password -h 127.0.0.1 -e "SHOW DATABASES;"
                        """
                        
                        // Test PHP application
                        sh """
                            # Test PHP application response
                            curl -f http://localhost:8089/ || echo "PHP application test failed"
                            
                            # Test Adminer interface
                            curl -f http://localhost:8083/ || echo "Adminer interface test failed"
                        """
                        
                        echo "All tests passed!"
                        
                    } catch (Exception e) {
                        echo "Test failed: ${e.getMessage()}"
                        sh """
                            echo "=== Service Logs ==="
                            COMPOSE_PROJECT_NAME=${TEST_COMPOSE_PROJECT_NAME} ${composeCmd} --env-file .env.test logs || echo 'Could not retrieve logs'
                            echo "=== Container Status ==="
                            COMPOSE_PROJECT_NAME=${TEST_COMPOSE_PROJECT_NAME} ${composeCmd} --env-file .env.test ps
                        """
                        throw e
                    } finally {
                        sh """
                            COMPOSE_PROJECT_NAME=${TEST_COMPOSE_PROJECT_NAME} ${composeCmd} --env-file .env.test down -v || true
                            rm -f .env.test || true
                        """
                    }
                }
            }
        }

        stage('Security Scan') {
            when {
                anyOf {
                    environment name: 'SKIP_SECURITY_SCAN', value: 'false'
                    environment name: 'FORCE_SECURITY_SCAN', value: 'true'
                }
            }
            steps {
                echo "Running security scan with Trivy..."
                script {
                    try {
                        def trivyAvailable = sh(
                            script: "docker run --rm aquasec/trivy:latest --version",
                            returnStatus: true
                        )
                        if (trivyAvailable != 0) {
                            echo "Trivy not available, skipping security scan"
                            currentBuild.result = 'UNSTABLE'
                            return
                        }
                        
                        echo "Running comprehensive vulnerability scan on PHP application..."
                        sh """
                            docker run --rm -v /var/run/docker.sock:/var/run/docker.sock \
                            aquasec/trivy:latest image \
                            --format table \
                            --severity LOW,MEDIUM,HIGH,CRITICAL \
                            ${IMAGE_NAME}:${BUILD_TAG} || true
                        """
                        
                        echo "Checking for CRITICAL vulnerabilities only..."
                        def criticalScanResult = sh(
                            script: """
                                docker run --rm -v /var/run/docker.sock:/var/run/docker.sock \
                                aquasec/trivy:latest image \
                                --exit-code 1 --severity CRITICAL \
                                --format table \
                                ${IMAGE_NAME}:${BUILD_TAG} || true
                            """,
                            returnStatus: true
                        )
                        
                        if (criticalScanResult == 0) {
                            echo "No CRITICAL vulnerabilities found"
                        } else {
                            echo "CRITICAL vulnerabilities found - marking build as unstable"
                            currentBuild.result = 'UNSTABLE'
                        }
                        echo "Security scan completed"
                    } catch (Exception e) {
                        echo "Security scan failed: ${e.getMessage()}"
                        currentBuild.result = 'UNSTABLE'
                    }
                }
            }
        }

        stage('Push to Docker Hub') {
            when {
                anyOf {
                    branch 'main'
                    branch 'develop'
                    environment name: 'ENABLE_DOCKER_PUSH', value: 'true'
                    environment name: 'FORCE_BRANCH_MAIN', value: 'true'
                    environment name: 'FORCE_BRANCH_DEVELOP', value: 'true'
                }
            }
            steps {
                echo "Pushing image to Docker Hub..."
                script {
                    try {
                        try {
                            docker.withRegistry("${DOCKER_REGISTRY}", 'dockerhub-credentials') {
                                def image = docker.image("${IMAGE_NAME}:${BUILD_TAG}")
                                image.push()
                                image.push("jenkins-latest")
                                if (env.BRANCH_NAME == 'main' || env.FORCE_BRANCH_MAIN == 'true') {
                                    image.push("production")
                                    image.push("v1.0.0")
                                } else if (env.BRANCH_NAME == 'develop' || env.FORCE_BRANCH_DEVELOP == 'true') {
                                    image.push("staging")
                                    image.push("develop-latest")
                                }
                                echo "Image pushed successfully with credentials"
                            }
                        } catch (Exception credError) {
                            echo "Docker Hub credentials not found, attempting push without registry authentication..."
                            sh """
                                docker push ${IMAGE_NAME}:${BUILD_TAG} || echo "Push failed - check Docker Hub login"
                                docker push ${IMAGE_NAME}:jenkins-latest || echo "Push failed - check Docker Hub login"
                            """
                            echo "Image push attempted (check Docker Hub for results)"
                        }
                    } catch (Exception e) {
                        echo "Docker Hub push failed: ${e.getMessage()}"
                        echo "To fix: Run 'docker login' on Jenkins agent or configure 'dockerhub-credentials'"
                        currentBuild.result = 'UNSTABLE'
                    }
                }
            }
        }

        stage('Deploy to Staging') {
            when {
                anyOf {
                    branch 'develop'
                    environment name: 'ENABLE_STAGING_DEPLOY', value: 'true'
                    environment name: 'FORCE_BRANCH_DEVELOP', value: 'true'
                }
            }
            steps {
                echo "Deploying to staging..."
                script {
                    deployToEnvironment('staging', '8090', '3308', '8084')
                }
            }
        }

        stage('Deploy to Production') {
            when {
                anyOf {
                    branch 'main'
                    environment name: 'ENABLE_PRODUCTION_DEPLOY', value: 'true'
                    environment name: 'FORCE_BRANCH_MAIN', value: 'true'
                }
            }
            steps {
                script {
                    if (env.SKIP_PRODUCTION_APPROVAL != 'true') {
                        try {
                            timeout(time: 5, unit: 'MINUTES') {
                                input message: 'Deploy to production?', ok: 'Deploy'
                            }
                        } catch (Exception e) {
                            echo "Production deployment approval timeout or skipped"
                            return
                        }
                    }
                    echo "Deploying to production..."
                    deployToEnvironment('production', '8091', '3309', '8085')
                }
            }
        }
    }

    post {
        always {
            echo "Cleaning up..."
            script {
                sh """
                    # Stop and remove test containers
                    docker compose -p ${TEST_COMPOSE_PROJECT_NAME} down -v || true
                    docker-compose -p ${TEST_COMPOSE_PROJECT_NAME} down -v || true
                    
                    # Clean up old images and containers
                    docker system prune -f --filter "until=24h" || true
                    
                    # Remove test environment file
                    rm -f .env.test .env.staging .env.production || true
                """
            }
        }

        success {
            echo "Pipeline completed successfully!"
            script {
                try {
                    if (env.EMAIL_CONFIGURED == 'true') {
                        emailext(
                            subject: "PHP-MySQL Build Success: ${env.JOB_NAME} #${env.BUILD_NUMBER}",
                            body: """
                                PHP-MySQL application build succeeded!

                                Job: ${env.JOB_NAME}
                                Build Number: ${env.BUILD_NUMBER}
                                Branch: ${env.BRANCH_NAME ?: 'main'}
                                Image: ${IMAGE_NAME}:${BUILD_TAG}
                                Application Directory: ${APP_DIR}

                                GitHub: ${GITHUB_REPO}
                                Docker Hub: https://hub.docker.com/r/${DOCKER_USERNAME}/${DOCKER_REPO}
                                Build URL: ${env.BUILD_URL}
                            """,
                            recipientProviders: [developers()]
                        )
                    } else {
                        echo "Email notification skipped - EMAIL_CONFIGURED not set to true"
                    }
                } catch (Exception e) {
                    echo "Failed to send success email: ${e.getMessage()}"
                }
            }
        }

        failure {
            echo "Pipeline failed!"
            script {
                try {
                    if (env.EMAIL_CONFIGURED == 'true') {
                        emailext(
                            subject: "PHP-MySQL Build Failed: ${env.JOB_NAME} #${env.BUILD_NUMBER}",
                            body: """
                                PHP-MySQL application build failed!

                                Job: ${env.JOB_NAME}
                                Branch: ${env.BRANCH_NAME ?: 'main'}
                                Application Directory: ${APP_DIR}
                                Build URL: ${env.BUILD_URL}

                                Please check the console output for details:
                                ${env.BUILD_URL}console
                            """,
                            recipientProviders: [developers(), requestor()]
                        )
                    } else {
                        echo "Email notification skipped - EMAIL_CONFIGURED not set to true"
                    }
                } catch (Exception e) {
                    echo "Failed to send failure email: ${e.getMessage()}"
                }
            }
        }

        unstable {
            echo "Pipeline completed with warnings."
        }
    }
}

def deployToEnvironment(environment, phpPort, mysqlPort, adminerPort) {
    def projectName = "php-mysql-app-${environment}"
    def composeCmd = sh(
        script: "docker compose version >/dev/null 2>&1 && echo 'docker compose' || echo 'docker-compose'",
        returnStdout: true
    ).trim()
    
    try {
        echo "Deploying PHP-MySQL application to ${environment}"
        echo "PHP Port: ${phpPort}, MySQL Port: ${mysqlPort}, Adminer Port: ${adminerPort}"
        
        // Create environment-specific .env file based on main .env
        sh """
            # Create environment-specific .env file
            cp .env .env.${environment}
            
            # Override specific values for deployment environment
            sed -i 's/MYSQL_ROOT_PASSWORD=.*/MYSQL_ROOT_PASSWORD=rootpass_${environment}/' .env.${environment}
            sed -i 's/MYSQL_DATABASE=.*/MYSQL_DATABASE=mydb_${environment}/' .env.${environment}
            sed -i 's/MYSQL_USER=.*/MYSQL_USER=sqluser_${environment}/' .env.${environment}
            sed -i 's/MYSQL_PASSWORD=.*/MYSQL_PASSWORD=MyAppUserPass456_${environment}/' .env.${environment}
            sed -i 's/PHP_EXTERNAL_PORT=.*/PHP_EXTERNAL_PORT=${phpPort}/' .env.${environment}
            sed -i 's/MYSQL_EXTERNAL_PORT=.*/MYSQL_EXTERNAL_PORT=${mysqlPort}/' .env.${environment}
            sed -i 's/ADMINER_EXTERNAL_PORT=.*/ADMINER_EXTERNAL_PORT=${adminerPort}/' .env.${environment}
            sed -i 's/PHP_ENV=.*/PHP_ENV=${environment}/' .env.${environment}
            sed -i 's/MYSQL_APP_ENV=.*/MYSQL_APP_ENV=${environment}/' .env.${environment}
            
            echo "Environment-specific .env file created for ${environment}"
        """
        
        // Stop existing deployment
        sh """
            COMPOSE_PROJECT_NAME=${projectName} ${composeCmd} --env-file .env.${environment} down -v || true
        """
        
        // Deploy with Docker Compose
        sh """
            COMPOSE_PROJECT_NAME=${projectName} ${composeCmd} --env-file .env.${environment} up -d --build
        """
        
        echo "Waiting for deployment to stabilize..."
        sleep 60
        
        echo "Checking deployment health..."
        retry(15) {
            sleep(10)
            sh """
                # Check MySQL health
                COMPOSE_PROJECT_NAME=${projectName} ${composeCmd} --env-file .env.${environment} exec -T mysql-db mysqladmin ping -h 127.0.0.1 -u root --password=rootpass_${environment} --connect-timeout=5 || exit 1
                
                # Check PHP application health
                curl -f http://localhost:${phpPort}/ || exit 1
                
                # Check Adminer health
                curl -f http://localhost:${adminerPort}/ || exit 1
                
                echo "=== Service Status ==="
                COMPOSE_PROJECT_NAME=${projectName} ${composeCmd} --env-file .env.${environment} ps
            """
        }
        
        echo "Successfully deployed to ${environment}"
        echo "PHP Application: http://localhost:${phpPort}"
        echo "Adminer: http://localhost:${adminerPort}"
        echo "MySQL Connection: mysql -h127.0.0.1 -P${mysqlPort} -uroot -prootpass_${environment}"
        
    } catch (Exception e) {
        echo "Deployment to ${environment} failed: ${e.getMessage()}"
        echo "Checking what went wrong..."
        sh """
            echo "=== Service Logs ==="
            COMPOSE_PROJECT_NAME=${projectName} ${composeCmd} --env-file .env.${environment} logs || echo "No logs available"
            echo "=== Service Status ==="
            COMPOSE_PROJECT_NAME=${projectName} ${composeCmd} --env-file .env.${environment} ps
        """
        throw e
    }
}
