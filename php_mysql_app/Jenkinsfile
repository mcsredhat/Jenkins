pipeline {
    agent any

    environment {
        DOCKER_REGISTRY = 'https://index.docker.io/v1/'
        DOCKER_USERNAME = 'farajassulai'
        DOCKER_REPO = 'php-mysql-app'
        IMAGE_NAME = "${DOCKER_USERNAME}/${DOCKER_REPO}"
        BUILD_TAG = "${env.BUILD_NUMBER}-${env.GIT_COMMIT?.take(7) ?: 'unknown'}"
        CONTAINER_NAME = "php-mysql-project"
        TEST_CONTAINER_NAME = "php-mysql-test-${env.BUILD_NUMBER}"
        GITHUB_REPO = 'https://github.com/mcsredhat/Jenkins'
        APP_DIR = "php_mysql_app"
        SKIP_SECURITY_SCAN = 'false'
        ENABLE_DOCKER_PUSH = 'true'
        ENABLE_STAGING_DEPLOY = 'true'
        ENABLE_PRODUCTION_DEPLOY = 'true'
        FORCE_BRANCH_MAIN = 'true'
        FORCE_BRANCH_DEVELOP = 'false'
        EMAIL_CONFIGURED = 'false'
        COMPOSE_PROJECT_NAME = "php-mysql-app-${env.BUILD_NUMBER}"
        TEST_COMPOSE_PROJECT_NAME = "php-mysql-test-${env.BUILD_NUMBER}"
    }

    stages {
        stage('Clean Workspace') {
            steps {
                echo "Cleaning Jenkins workspace to avoid permission issues..."
                script {
                    // Log workspace permissions before cleanup
                    sh """
                        ls -ld /var/lib/jenkins/workspace/php_mysql_pipeline || echo "Workspace directory not found"
                        if [ -d /var/lib/jenkins/workspace/php_mysql_pipeline ]; then
                            ls -l /var/lib/jenkins/workspace/php_mysql_pipeline || echo "Cannot list workspace contents"
                        fi
                    """
                    // Attempt to clear workspace
                    deleteDir()
                    // Verify workspace is clean
                    sh """
                        ls -la /var/lib/jenkins/workspace/php_mysql_pipeline || echo "Workspace is empty after cleanup"
                    """
                }
            }
        }

        stage('Checkout') {
            steps {
                echo "Checking out code from GitHub repository..."
                checkout scm

                script {
                    echo "Current branch: ${env.BRANCH_NAME ?: 'main'}"
                    echo "Git commit: ${env.GIT_COMMIT ?: 'unknown'}"
                    echo "Repository URL: ${GITHUB_REPO}"
                    echo "Working in directory: ${pwd()}"
                    echo "Application directory: ${APP_DIR}"
                    
                    dir("${APP_DIR}") {
                        sh "pwd && ls -la"
                        echo "Checking Docker environment..."
                        sh """
                            docker --version || echo "Docker not found"
                            docker compose version 2>/dev/null && echo "Docker Compose (plugin) available" || echo "Docker Compose plugin not found"
                            docker-compose --version 2>/dev/null && echo "Docker Compose (standalone) available" || echo "Docker Compose standalone not found"
                        """
                        echo "Checking project structure..."
                        sh """
                            ls -la ./mysql/ ./mysql/config ./php-apache/ ./php-apache/src ./php-apache/apache-config ./php-apache/php-config || echo 'Some project directories not found'
                            ls -la docker-compose.yml .env || echo 'Docker Compose files not found'
                            ls -la ./mysql/Dockerfile ./php-apache/Dockerfile || echo 'Some Dockerfiles not found'
                            ls -la ./php-apache/src/index.php || echo 'index.php not found'
                            # Verify docker-compose.yml is not in volumes/
                            if [ -f volumes/docker-compose.yml ]; then
                                echo "Error: docker-compose.yml found in volumes/ directory. It should be in ${APP_DIR}/"
                                exit 1
                            fi
                        """
                    }
                }
            }
        }

        stage('Setup Environment') {
            steps {
                echo "Setting up environment..."
                script {
                    dir("${APP_DIR}") {
                        sh """
                            # Create necessary directories with correct permissions
                            mkdir -p volumes/php_data volumes/php_logs volumes/mysql_data volumes/mysql_logs
                            
                            # Set permissions using the jenkins user
                            chown -R \$(whoami):\$(whoami) volumes || echo "Warning: Could not change ownership of volumes directory"
                            chmod -R 755 volumes || echo "Warning: Could not set permissions on volumes directory"
                            
                            # Use Docker to ensure permissions if needed
                            docker run --rm -v \$(pwd)/volumes:/volumes alpine:latest sh -c "
                                chown -R 1000:1000 /volumes || echo 'Warning: Could not change ownership'
                                chmod -R 755 /volumes || echo 'Warning: Could not change permissions'
                            " || echo "Warning: Docker permission setup failed, continuing anyway"
                            
                            # Stop any existing containers and clean up networks
                            docker compose -p ${COMPOSE_PROJECT_NAME} down -v 2>/dev/null || docker-compose -p ${COMPOSE_PROJECT_NAME} down -v 2>/dev/null || echo "No compose services to stop"
                            docker compose -p ${TEST_COMPOSE_PROJECT_NAME} down -v 2>/dev/null || docker-compose -p ${TEST_COMPOSE_PROJECT_NAME} down -v 2>/dev/null || echo "No test compose services to stop"
                            
                            # Clean up unused containers and networks
                            docker container prune -f || true
                            docker network prune -f || true
                            # Remove all potential conflicting networks
                            docker network ls --filter name=php-mysql-app -q | xargs -r docker network rm 2>/dev/null || echo "No conflicting networks to remove"
                        """
                    }
                }
            }
        }

        stage('Build') {
            steps {
                echo "Building Docker images with Docker Compose..."
                script {
                    dir("${APP_DIR}") {
                        try {
                            def composeCmd = sh(
                                script: "docker compose version >/dev/null 2>&1 && echo 'docker compose' || echo 'docker-compose'",
                                returnStdout: true
                            ).trim()
                            echo "Using compose command: ${composeCmd}"
                            
                            sh """
                                # Validate files exist and have required content
                                pwd
                                ls -la
                                
                                if [ ! -f .env ]; then
                                    echo "Error: .env file not found in \$(pwd)"
                                    echo "Contents of current directory:"
                                    ls -la
                                    exit 1
                                fi
                                
                                if [ ! -f docker-compose.yml ]; then
                                    echo "Error: docker-compose.yml file not found in \$(pwd)"
                                    echo "Contents of current directory:"
                                    ls -la
                                    exit 1
                                fi
                                
                                grep -q "MYSQL_ROOT_PASSWORD=" .env || (echo "Error: MYSQL_ROOT_PASSWORD not found in .env" && exit 1)
                                grep -q "MYSQL_DATABASE=" .env || (echo "Error: MYSQL_DATABASE not found in .env" && exit 1)
                                grep -q "PHP_VERSION=" .env || (echo "Error: PHP_VERSION not found in .env" && exit 1)
                                
                                echo "Environment file validation passed"
                            """
                            
                            sh """
                                COMPOSE_PROJECT_NAME=${COMPOSE_PROJECT_NAME} ${composeCmd} build --no-cache 2>&1 | tee build.log
                                if [ \${PIPESTATUS[0]} -ne 0 ]; then
                                    echo "Docker Compose build failed, displaying build log:"
                                    cat build.log
                                    exit 1
                                fi
                            """
                            
                            sh """
                                PHP_IMAGE=\$(docker images --format "table {{.Repository}}:{{.Tag}}" | grep "${COMPOSE_PROJECT_NAME}" | grep php | head -1 | awk '{print \$1}')
                                if [ ! -z "\$PHP_IMAGE" ]; then
                                    docker tag \$PHP_IMAGE ${IMAGE_NAME}:${BUILD_TAG}
                                    docker tag \$PHP_IMAGE ${IMAGE_NAME}:latest
                                    echo "Tagged PHP image: \$PHP_IMAGE -> ${IMAGE_NAME}:${BUILD_TAG}"
                                else
                                    echo "Warning: Could not find PHP image to tag"
                                    echo "Available images:"
                                    docker images | grep "${COMPOSE_PROJECT_NAME}"
                                fi
                            """
                            
                            echo "Images built successfully with project name: ${COMPOSE_PROJECT_NAME}"
                        } catch (Exception e) {
                            echo "Build failed: ${e.getMessage()}"
                            sh "cat build.log || echo 'No build log available'"
                            throw e
                        }
                    }
                }
            }
        }

        stage('Test') {
            steps {
                echo "Running containerized tests with Docker Compose..."
                script {
                    dir("${APP_DIR}") {
                        def composeCmd = sh(
                            script: "docker compose version >/dev/null 2>&1 && echo 'docker compose' || echo 'docker-compose'",
                            returnStdout: true
                        ).trim()
                        
                        try {
                            sh """
                                cp .env .env.test
                                
                                sed -i 's/MYSQL_ROOT_PASSWORD=.*/MYSQL_ROOT_PASSWORD=test_rootpass/' .env.test
                                sed -i 's/MYSQL_DATABASE=.*/MYSQL_DATABASE=test_db/' .env.test
                                sed -i 's/MYSQL_USER=.*/MYSQL_USER=test_user/' .env.test
                                sed -i 's/MYSQL_PASSWORD=.*/MYSQL_PASSWORD=test_password/' .env.test
                                sed -i 's/PHP_EXTERNAL_PORT=.*/PHP_EXTERNAL_PORT=8089/' .env.test
                                sed -i 's/MYSQL_EXTERNAL_PORT=.*/MYSQL_EXTERNAL_PORT=3307/' .env.test
                                sed -i 's/ADMINER_EXTERNAL_PORT=.*/ADMINER_EXTERNAL_PORT=8083/' .env.test
                                echo 'MYSQL_HOST=mysql-db' >> .env.test
                                
                                echo "Test environment file created:"
                                cat .env.test
                            """
                            
                            sh """
                                COMPOSE_PROJECT_NAME=${TEST_COMPOSE_PROJECT_NAME} ${composeCmd} --env-file .env.test up -d --build
                            """
                            
                            echo "Waiting for services to start..."
                            sleep 15
                            
                            retry(10) {
                                sleep(5)
                                sh """
                                    COMPOSE_PROJECT_NAME=${TEST_COMPOSE_PROJECT_NAME} ${composeCmd} --env-file .env.test exec -T mysql-db mysqladmin ping -h mysql-db -u root --password=test_rootpass --connect-timeout=5
                                """
                            }
                            
                            echo "MySQL is ready! Running tests..."
                            
                            sh """
                                # Verify MySQL user creation
                                COMPOSE_PROJECT_NAME=${TEST_COMPOSE_PROJECT_NAME} ${composeCmd} --env-file .env.test exec -T mysql-db mysql -uroot -ptest_rootpass -h mysql-db -e "SELECT User, Host FROM mysql.user;"
                                COMPOSE_PROJECT_NAME=${TEST_COMPOSE_PROJECT_NAME} ${composeCmd} --env-file .env.test exec -T mysql-db mysql -uroot -ptest_rootpass -h mysql-db -e "SHOW DATABASES;"
                                COMPOSE_PROJECT_NAME=${TEST_COMPOSE_PROJECT_NAME} ${composeCmd} --env-file .env.test exec -T mysql-db mysql -uroot -ptest_rootpass -h mysql-db -e "USE test_db; CREATE TABLE IF NOT EXISTS test_table (id INT PRIMARY KEY, name VARCHAR(50));"
                                COMPOSE_PROJECT_NAME=${TEST_COMPOSE_PROJECT_NAME} ${composeCmd} --env-file .env.test exec -T mysql-db mysql -uroot -ptest_rootpass -h mysql-db -e "USE test_db; INSERT IGNORE INTO test_table (id, name) VALUES (1, 'test');"
                                COMPOSE_PROJECT_NAME=${TEST_COMPOSE_PROJECT_NAME} ${composeCmd} --env-file .env.test exec -T mysql-db mysql -uroot -ptest_rootpass -h mysql-db -e "USE test_db; SELECT * FROM test_table;"
                                
                                # Test connection with test_user
                                COMPOSE_PROJECT_NAME=${TEST_COMPOSE_PROJECT_NAME} ${composeCmd} --env-file .env.test exec -T mysql-db mysql -utest_user -ptest_password -h mysql-db -e "USE test_db; SELECT * FROM test_table;" || {
                                    echo "Failed to connect with test_user. Dumping MySQL user info:"
                                    COMPOSE_PROJECT_NAME=${TEST_COMPOSE_PROJECT_NAME} ${composeCmd} --env-file .env.test exec -T mysql-db mysql -uroot -ptest_rootpass -h mysql-db -e "SELECT User, Host, authentication_string FROM mysql.user;"
                                    exit 1
                                }
                            """
                            
                            sh """
                                # List files in PHP container to debug
                                COMPOSE_PROJECT_NAME=${TEST_COMPOSE_PROJECT_NAME} ${composeCmd} --env-file .env.test exec -T php-apache ls -la /var/www/html
                                
                                # Verify PHP application connectivity
                                curl -f http://localhost:8089/ || {
                                    echo "PHP application test failed. Dumping container logs:"
                                    COMPOSE_PROJECT_NAME=${TEST_COMPOSE_PROJECT_NAME} ${composeCmd} --env-file .env.test logs php-apache
                                    echo "PHP application source code:"
                                    COMPOSE_PROJECT_NAME=${TEST_COMPOSE_PROJECT_NAME} ${composeCmd} --env-file .env.test exec -T php-apache cat /var/www/html/index.php || echo "index.php not found"
                                    exit 1
                                }
                                curl -f http://localhost:8083/ || {
                                    echo "Adminer interface test failed. Dumping container logs:"
                                    COMPOSE_PROJECT_NAME=${TEST_COMPOSE_PROJECT_NAME} ${composeCmd} --env-file .env.test logs adminer
                                    exit 1
                                }
                            """
                            
                            echo "All tests passed!"
                            
                        } catch (Exception e) {
                            echo "Test failed: ${e.getMessage()}"
                            sh """
                                echo "=== Service Logs ==="
                                COMPOSE_PROJECT_NAME=${TEST_COMPOSE_PROJECT_NAME} ${composeCmd} --env-file .env.test logs || echo 'Could not retrieve logs'
                                echo "=== Container Status ==="
                                COMPOSE_PROJECT_NAME=${TEST_COMPOSE_PROJECT_NAME} ${composeCmd} --env-file .env.test ps
                                echo "=== MySQL User Info ==="
                                COMPOSE_PROJECT_NAME=${TEST_COMPOSE_PROJECT_NAME} ${composeCmd} --env-file .env.test exec -T mysql-db mysql -uroot -ptest_rootpass -h mysql-db -e "SELECT User, Host, authentication_string FROM mysql.user;" || echo "Could not retrieve MySQL user info"
                                echo "=== PHP Application Files ==="
                                COMPOSE_PROJECT_NAME=${TEST_COMPOSE_PROJECT_NAME} ${composeCmd} --env-file .env.test exec -T php-apache ls -la /var/www/html || echo "Could not list PHP application files"
                            """
                            throw e
                        } finally {
                            sh """
                                COMPOSE_PROJECT_NAME=${TEST_COMPOSE_PROJECT_NAME} ${composeCmd} --env-file .env.test down -v || true
                                rm -f .env.test || true
                            """
                        }
                    }
                }
            }
        }

        stage('Security Scan') {
            when {
                anyOf {
                    environment name: 'SKIP_SECURITY_SCAN', value: 'false'
                    environment name: 'FORCE_SECURITY_SCAN', value: 'true'
                }
            }
            steps {
                echo "Running security scan with Trivy..."
                script {
                    dir("${APP_DIR}") {
                        try {
                            def trivyAvailable = sh(
                                script: "docker run --rm aquasec/trivy:latest --version",
                                returnStatus: true
                            )
                            if (trivyAvailable != 0) {
                                echo "Trivy not available, skipping security scan"
                                currentBuild.result = 'UNSTABLE'
                                return
                            }
                            
                            sh """
                                docker run --rm -v /var/run/docker.sock:/var/run/docker.sock \
                                aquasec/trivy:latest image \
                                --format table \
                                --severity LOW,MEDIUM,HIGH,CRITICAL \
                                ${IMAGE_NAME}:${BUILD_TAG} || true
                            """
                            
                            def criticalScanResult = sh(
                                script: """
                                    docker run --rm -v /var/run/docker.sock:/var/run/docker.sock \
                                    aquasec/trivy:latest image \
                                    --exit-code 1 --severity CRITICAL \
                                    --format table \
                                    ${IMAGE_NAME}:${BUILD_TAG} || true
                                """,
                                returnStatus: true
                            )
                            
                            if (criticalScanResult == 0) {
                                echo "No CRITICAL vulnerabilities found"
                            } else {
                                echo "CRITICAL vulnerabilities found - marking build as unstable"
                                currentBuild.result = 'UNSTABLE'
                            }
                            echo "Security scan completed"
                        } catch (Exception e) {
                            echo "Security scan failed: ${e.getMessage()}"
                            currentBuild.result = 'UNSTABLE'
                        }
                    }
                }
            }
        }
