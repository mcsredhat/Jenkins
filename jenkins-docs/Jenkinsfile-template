pipeline {
    agent any

    // Global environment variables for all application types
    environment {
        DOCKER_REGISTRY = 'https://index.docker.io/v1/'
        DOCKER_USERNAME = 'farajassulai'                    // Configurable Docker Hub username
        DOCKER_REPO = "${env.APP_TYPE}-app"                // Dynamic repo name based on app type
        IMAGE_NAME = "${DOCKER_USERNAME}/${DOCKER_REPO}"
        BUILD_TAG = "${env.BUILD_NUMBER}-${env.GIT_COMMIT?.take(7) ?: 'unknown'}"
        CONTAINER_NAME = "${env.APP_TYPE}-${env.BUILD_NUMBER}"
        TEST_CONTAINER_NAME = "test-${env.APP_TYPE}-${env.BUILD_NUMBER}"
        GITHUB_REPO = 'https://github.com/mcsredhat/Jenkins' // Configurable GitHub repo
        APP_PORT = "${env.APP_PORT ?: '8383'}"             // Default port, override per app
        TEST_PORT = "${env.TEST_PORT ?: '9393'}"           // Default test port, override per app
        APP_DIR = "${env.APP_DIR ?: '.'}"                  // Default to root, override per app
        COMPOSE_FILE = "${env.COMPOSE_FILE ?: 'docker-compose.yml'}" // Default compose file
        USE_COMPOSE = "${env.USE_COMPOSE ?: 'false'}"      // Flag to use docker-compose
        APP_TYPE = "${env.APP_TYPE ?: 'generic'}"          // Application type (node, nginx, flask, etc.)

        // Control flags
        SKIP_SECURITY_SCAN = 'false'                       // Enable security scans by default
        ENABLE_DOCKER_PUSH = 'true'                        // Enable Docker push
        ENABLE_STAGING_DEPLOY = 'true'                     // Enable staging deployment
        ENABLE_PRODUCTION_DEPLOY = 'true'                  // Enable production deployment
        FORCE_BRANCH_MAIN = 'true'                         // Force main branch for testing
        FORCE_BRANCH_DEVELOP = 'false'                     // Force develop branch for testing
        EMAIL_CONFIGURED = 'false'                         // Email notifications disabled by default
    }

    stages {
        stage('Checkout') {
            steps {
                echo "üì¶ Checking out code from GitHub repository..."
                checkout scm

                script {
                    echo "Current branch: ${env.BRANCH_NAME ?: 'main'}"
                    echo "Git commit: ${env.GIT_COMMIT ?: 'unknown'}"
                    echo "Repository URL: ${GITHUB_REPO}"
                    echo "Working in directory: ${pwd()}"
                    sh "ls -la"
                    
                    // Check application directory
                    echo "Checking for application directory: ${APP_DIR}"
                    sh "ls -la ${APP_DIR}/ || echo 'Application directory not found'"
                    
                    // Check for required files
                    echo "Checking for required files in ${APP_DIR}:"
                    sh """
                        cd ${APP_DIR}
                        ls -la Dockerfile ${COMPOSE_FILE} Jenkinsfile || echo 'Dockerfile or ${COMPOSE_FILE} Jenkinsfile not found'
                    """
                }
            }
        }

        stage('Build') {
            steps {
                echo "üîß Building Docker image..."
                script {
                    try {
                        dir(APP_DIR) {
                            if (env.USE_COMPOSE == 'true') {
                                // Build using docker-compose
                                sh """
                                    docker-compose -f ${COMPOSE_FILE} build
                                    docker tag ${IMAGE_NAME}:${BUILD_TAG} ${IMAGE_NAME}:jenkins-build 
                                """
                                echo "‚úÖ Docker-compose build completed"
                            } else {
                                // Build using Dockerfile
                                def image = docker.build("${IMAGE_NAME}:${BUILD_TAG}", ".")
                                image.tag("jenkins-build")
                                echo "‚úÖ Dockerfile build completed: ${IMAGE_NAME}:${BUILD_TAG}"
                            }
                        }
                    } catch (Exception e) {
                        echo "‚ùå Build failed: ${e.getMessage()}"
                        throw e
                    }
                }
            }
        }

        stage('Test') {
            steps {
                echo "üß™ Running containerized tests..."
                script {
                    try {
                        if (env.USE_COMPOSE == 'true') {
                            // Run tests with docker-compose
                            sh """
                                docker-compose -f ${APP_DIR}/${COMPOSE_FILE} up -d
                            """
                        } else {
                            // Run tests with single container
                            sh """
                                docker run -d --name ${TEST_CONTAINER_NAME} \
                                    -p ${TEST_PORT}:${APP_PORT} \
                                    -e ENVIRONMENT=test \
                                    -e APP_PORT=${APP_PORT} \
                                    ${IMAGE_NAME}:${BUILD_TAG}
                            """
                        }

                        echo "‚åõ Waiting for application to start..."
                        retry(5) {
                            sleep 10
                            sh """
                                curl -f http://localhost:${TEST_PORT}/health || \
                                curl -f http://localhost:${TEST_PORT}/ || \
                                echo "Health check failed, continuing with warning..."
                            """
                        }

                        // Additional tests based on app type
                        if (env.APP_TYPE == 'nginx') {
                            sh """
                                curl -I http://localhost:${TEST_PORT}/ | head -1
                                docker exec ${TEST_CONTAINER_NAME} ps aux | grep nginx || echo "Nginx process check failed"
                            """
                        }

                        echo "‚úÖ Tests passed!"
                    } catch (Exception e) {
                        echo "‚ùå Test failed: ${e.getMessage()}"
                        sh "docker logs ${TEST_CONTAINER_NAME} || echo 'Could not retrieve logs'"
                        throw e
                    } finally {
                        if (env.USE_COMPOSE == 'true') {
                            sh "docker-compose -f ${APP_DIR}/${COMPOSE_FILE} down || true"
                        } else {
                            sh """
                                docker stop ${TEST_CONTAINER_NAME} || true
                                docker rm ${TEST_CONTAINER_NAME} || true
                            """
                        }
                    }
                }
            }
        }

        stage('Security Scan') {
            when {
                anyOf {
                    environment name: 'SKIP_SECURITY_SCAN', value: 'false'
                    environment name: 'FORCE_SECURITY_SCAN', value: 'true'
                }
            }
            steps {
                echo "üîç Running security scan with Trivy..."
                script {
                    try {
                        def trivyAvailable = sh(
                            script: "docker run --rm aquasec/trivy:latest --version",
                            returnStatus: true
                        )
                        
                        if (trivyAvailable != 0) {
                            echo "‚ö†Ô∏è Trivy not available, skipping security scan"
                            currentBuild.result = 'UNSTABLE'
                            return
                        }
                        
                        echo "üìä Running comprehensive vulnerability scan..."
                        sh """
                            docker run --rm -v /var/run/docker.sock:/var/run/docker.sock \
                            aquasec/trivy:latest image \
                            --format table \
                            --severity LOW,MEDIUM,HIGH,CRITICAL \
                            ${IMAGE_NAME}:${BUILD_TAG} || true
                        """
                        
                        echo "üö® Checking for CRITICAL vulnerabilities..."
                        def criticalScanResult = sh(
                            script: """
                                docker run --rm -v /var/run/docker.sock:/var/run/docker.sock \
                                aquasec/trivy:latest image \
                                --exit-code 1 --severity CRITICAL \
                                --format table \
                                ${IMAGE_NAME}:${BUILD_TAG} || true
                            """,
                            returnStatus: true
                        )
                        
                        if (criticalScanResult == 0) {
                            echo "‚úÖ No CRITICAL vulnerabilities found"
                        } else {
                            echo "‚ö†Ô∏è CRITICAL vulnerabilities found - marking build as unstable"
                            currentBuild.result = 'UNSTABLE'
                        }
                        
                        echo "‚úÖ Security scan completed"
                    } catch (Exception e) {
                        echo "‚ùå Security scan failed: ${e.getMessage()}"
                        currentBuild.result = 'UNSTABLE'
                    }
                }
            }
        }

        stage('Push to Docker Hub') {
            when {
                anyOf {
                    branch 'main'
                    branch 'develop'
                    environment name: 'ENABLE_DOCKER_PUSH', value: 'true'
                    environment name: 'FORCE_BRANCH_MAIN', value: 'true'
                    environment name: 'FORCE_BRANCH_DEVELOP', value: 'true'
                }
            }
            steps {
                echo "üì§ Pushing image to Docker Hub..."
                script {
                    try {
                        try {
                            docker.withRegistry("${DOCKER_REGISTRY}", 'dockerhub-credentials') {
                                def image = docker.image("${IMAGE_NAME}:${BUILD_TAG}")
                                image.push()
                                image.push("jenkins-latest")

                                if (env.BRANCH_NAME == 'main' || env.FORCE_BRANCH_MAIN == 'true') {
                                    image.push("production")
                                    image.push("v1.0.0")
                                } else if (env.BRANCH_NAME == 'develop' || env.FORCE_BRANCH_DEVELOP == 'true') {
                                    image.push("staging")
                                    image.push("develop-latest")
                                }
                                
                                echo "‚úÖ Image pushed successfully with credentials"
                            }
                        } catch (Exception credError) {
                            echo "‚ö†Ô∏è Docker Hub credentials not found, attempting push without authentication..."
                            sh """
                                docker push ${IMAGE_NAME}:${BUILD_TAG} || echo "Push failed - check Docker Hub login"
                                docker push ${IMAGE_NAME}:jenkins-latest || echo "Push failed - check Docker Hub login"
                            """
                            echo "‚úÖ Image push attempted (check Docker Hub for results)"
                        }
                    } catch (Exception e) {
                        echo "‚ùå Docker Hub push failed: ${e.getMessage()}"
                        echo "üí° To fix: Run 'docker login' on Jenkins agent or configure 'dockerhub-credentials'"
                        currentBuild.result = 'UNSTABLE'
                    }
                }
            }
        }

        stage('Deploy to Staging') {
            when {
                anyOf {
                    branch 'develop'
                    environment name: 'ENABLE_STAGING_DEPLOY', value: 'true'
                    environment name: 'FORCE_BRANCH_DEVELOP', value: 'true'
                }
            }
            steps {
                echo "üöÄ Deploying to staging..."
                script {
                    deployToEnvironment('staging', "${env.STAGING_PORT ?: '8088'}")
                }
            }
        }

        stage('Deploy to Production') {
            when {
                anyOf {
                    branch 'main'
                    environment name: 'ENABLE_PRODUCTION_DEPLOY', value: 'true'
                    environment name: 'FORCE_BRANCH_MAIN', value: 'true'
                }
            }
            steps {
                script {
                    if (env.SKIP_PRODUCTION_APPROVAL != 'true') {
                        try {
                            timeout(time: 5, unit: 'MINUTES') {
                                input message: 'Deploy to production?', ok: 'Deploy'
                            }
                        } catch (Exception e) {
                            echo "‚ö†Ô∏è Production deployment approval timeout or skipped"
                            return
                        }
                    }
                    echo "üöÄ Deploying to production..."
                    deployToEnvironment('production', "${env.PRODUCTION_PORT ?: '9090'}")
                }
            }
        }
    }

    post {
        always {
            echo "üßπ Cleaning up..."
            script {
                if (env.USE_COMPOSE == 'true') {
                    sh "docker-compose -f ${APP_DIR}/${COMPOSE_FILE} down || true"
                }
                sh """
                    docker stop ${TEST_CONTAINER_NAME} || true
                    docker rm ${TEST_CONTAINER_NAME} || true
                    docker system prune -f --filter "until=24h"
                """
            }
        }

        success {
            echo "‚úÖ Pipeline completed successfully!"
            script {
                try {
                    if (env.EMAIL_CONFIGURED == 'true') {
                        emailext(
                            subject: "‚úÖ ${env.APP_TYPE} Build Success: ${env.JOB_NAME} #${env.BUILD_NUMBER}",
                            body: """
                                ‚úîÔ∏è ${env.APP_TYPE} build succeeded!

                                Job: ${env.JOB_NAME}
                                Build Number: ${env.BUILD_NUMBER}
                                Branch: ${env.BRANCH_NAME ?: 'main'}
                                Image: ${IMAGE_NAME}:${BUILD_TAG}

                                GitHub: ${GITHUB_REPO}
                                Docker Hub: https://hub.docker.com/r/${DOCKER_USERNAME}/${DOCKER_REPO}
                                Build URL: ${env.BUILD_URL}
                            """,
                            recipientProviders: [developers()]
                        )
                    } else {
                        echo "Email notification skipped - EMAIL_CONFIGURED not set to true"
                    }
                } catch (Exception e) {
                    echo "‚ö†Ô∏è Failed to send success email: ${e.getMessage()}"
                }
            }
        }

        failure {
            echo "‚ùå Pipeline failed!"
            script {
                try {
                    if (env.EMAIL_CONFIGURED == 'true') {
                        emailext(
                            subject: "‚ùå ${env.APP_TYPE} Build Failed: ${env.JOB_NAME} #${env.BUILD_NUMBER}",
                            body: """
                                ‚ùå ${env.APP_TYPE} build failed!

                                Job: ${env.JOB_NAME}
                                Branch: ${env.BRANCH_NAME ?: 'main'}
                                Build URL: ${env.BUILD_URL}

                                Please check the console output for details:
                                ${env.BUILD_URL}console
                            """,
                            recipientProviders: [developers(), requestor()]
                        )
                    } else {
                        echo "Email notification skipped - EMAIL_CONFIGURED not set to true"
                    }
                } catch (Exception e) {
                    echo "‚ö†Ô∏è Failed to send failure email: ${e.getMessage()}"
                }
            }
        }

        unstable {
            echo "‚ö†Ô∏è Pipeline completed with warnings."
        }
    }
}

// Generalized deployment function
def deployToEnvironment(environment, port) {
    def containerName = "${env.APP_TYPE}-app-${environment}"
    try {
        echo "üöÄ Deploying ${IMAGE_NAME}:${BUILD_TAG} to ${environment} on port ${port}"
        
        if (env.USE_COMPOSE == 'true') {
            sh """
                docker-compose -f ${APP_DIR}/${COMPOSE_FILE} up -d
            """
        } else {
            sh """
                docker stop ${containerName} || true
                docker rm ${containerName} || true
                docker run -d \
                    --name ${containerName} \
                    -p ${port}:${APP_PORT} \
                    -e ENVIRONMENT=${environment} \
                    -e APP_PORT=${APP_PORT} \
                    --restart=unless-stopped \
                    --memory=512m \
                    --cpus=0.5 \
                    --health-cmd="curl -f http://localhost:${APP_PORT}/health || exit 1" \
                    --health-interval=30s \
                    --health-timeout=10s \
                    --health-retries=3 \
                    ${IMAGE_NAME}:${BUILD_TAG}
            """
        }

        echo "‚åõ Waiting for deployment to stabilize..."
        sleep 15

        echo "üîç Checking deployment health..."
        retry(3) {
            sh """
                echo "Testing health endpoint..."
                curl -f http://localhost:${port}/health || \
                curl -f http://localhost:${port}/ || \
                echo "Health check failed but continuing..."
            """
        }

        echo "‚úÖ Successfully deployed ${env.APP_TYPE} to ${environment} on port ${port}"
        echo "üåê Access the application at: http://localhost:${port}"
        
        sh "docker ps | grep ${containerName} || echo 'Container not found in ps'"
        
    } catch (Exception e) {
        echo "‚ùå Deployment to ${environment} failed: ${e.getMessage()}"
        echo "üîç Checking what went wrong..."
        sh """
            docker logs ${containerName} || echo "No logs available"
            docker ps -a | grep ${containerName} || echo "Container not found"
        """
        throw e
    }
}