pipeline {
    agent any

    environment {
        DOCKER_REGISTRY = 'https://index.docker.io/v1/'
        DOCKER_USERNAME = 'farajassulai'
        DOCKER_REPO = 'mysql-db'
        IMAGE_NAME = "${DOCKER_USERNAME}/${DOCKER_REPO}"
        BUILD_TAG = "${env.BUILD_NUMBER}-${env.GIT_COMMIT?.take(7) ?: 'unknown'}"
        CONTAINER_NAME = "mysql-project"
        TEST_CONTAINER_NAME = "test-mysql-${env.BUILD_NUMBER}"
        GITHUB_REPO = 'https://github.com/mcsredhat/Jenkins'
        APP_PORT = "3306"
        TEST_PORT = "3366"
        APP_DIR = "mysql"
        SKIP_SECURITY_SCAN = 'false'
        ENABLE_DOCKER_PUSH = 'true'
        ENABLE_STAGING_DEPLOY = 'true'
        ENABLE_PRODUCTION_DEPLOY = 'true'
        FORCE_BRANCH_MAIN = 'true'
        FORCE_BRANCH_DEVELOP = 'false'
        EMAIL_CONFIGURED = 'false'
    }

    stages {
        stage('Checkout') {
            steps {
                echo "Checking out code from GitHub repository..."
                checkout scm

                script {
                    echo "Current branch: ${env.BRANCH_NAME ?: 'main'}"
                    echo "Git commit: ${env.GIT_COMMIT ?: 'unknown'}"
                    echo "Repository URL: ${GITHUB_REPO}"
                    echo "Working in directory: ${pwd()}"
                    sh "ls -la"
                    echo "Checking Docker environment..."
                    sh """
                        docker --version || echo "Docker not found"
                        docker compose version 2>/dev/null && echo "Docker Compose (plugin) available" || echo "Docker Compose plugin not found"
                        docker-compose --version 2>/dev/null && echo "Docker Compose (standalone) available" || echo "Docker Compose standalone not found"
                    """
                    echo "Checking for application directory: ${APP_DIR}"
                    sh "ls -la ${APP_DIR}/ || echo 'Application directory not found'"
                    echo "Checking for required files in ${APP_DIR}:"
                    sh """
                        cd ${APP_DIR}
                        ls -la Dockerfile docker-compose.yml .env || echo 'Some files not found in ${APP_DIR}'
                        ls -la ./config/my.cnf ./config/init.sql || echo 'Config files not found in ${APP_DIR}/config'
                    """
                }
            }
        }

        stage('Setup Environment') {
            steps {
                echo "Setting up environment..."
                script {
                    dir(APP_DIR) {
                        sh """
                            mkdir -p mysql_data mysql_logs
                            chmod 755 mysql_data mysql_logs
                        """
                        sh """
                            docker compose down 2>/dev/null || docker-compose down 2>/dev/null || echo "No compose services to stop"
                            docker container prune -f || true
                        """
                    }
                }
            }
        }

        stage('Build') {
            steps {
                echo "Building Docker image..."
                script {
                    try {
                        dir(APP_DIR) {
                            def composeCmd = sh(
                                script: "docker compose version >/dev/null 2>&1 && echo 'docker compose' || echo 'docker-compose'",
                                returnStdout: true
                            ).trim()
                            echo "Using compose command: ${composeCmd}"
                            def buildResult = sh(
                                script: "${composeCmd} build 2>&1 || echo 'compose_failed'",
                                returnStdout: true
                            ).trim()
                            if (buildResult.contains('compose_failed')) {
                                echo "Docker Compose not available, building manually..."
                                sh """
                                    docker build -t ${IMAGE_NAME}:${BUILD_TAG} . 2>&1 | tee build.log
                                    if [ \${PIPESTATUS[0]} -ne 0 ]; then
                                        echo "Docker build failed, displaying build log:"
                                        cat build.log
                                        exit 1
                                    fi
                                    docker tag ${IMAGE_NAME}:${BUILD_TAG} ${IMAGE_NAME}:latest
                                """
                            } else {
                                echo "Built with Docker Compose"
                                sh """
                                    COMPOSE_IMAGE=\$(docker images --format "table {{.Repository}}:{{.Tag}}" | grep mysql | head -1)
                                    if [ ! -z "\$COMPOSE_IMAGE" ]; then
                                        docker tag \$COMPOSE_IMAGE ${IMAGE_NAME}:${BUILD_TAG}
                                        docker tag \$COMPOSE_IMAGE ${IMAGE_NAME}:latest
                                    else
                                        echo "No compose image found, building manually..."
                                        docker build -t ${IMAGE_NAME}:${BUILD_TAG} . 2>&1 | tee build.log
                                        if [ \${PIPESTATUS[0]} -ne 0 ]; then
                                            echo "Docker build failed, displaying build log:"
                                            cat build.log
                                            exit 1
                                        fi
                                        docker tag ${IMAGE_NAME}:${BUILD_TAG} ${IMAGE_NAME}:latest
                                    fi
                                """
                            }
                            echo "Image built successfully: ${IMAGE_NAME}:${BUILD_TAG}"
                        }
                    } catch (Exception e) {
                        echo "Build failed: ${e.getMessage()}"
                        sh "cat ${APP_DIR}/build.log || echo 'No build log available'"
                        throw e
                    }
                }
            }
        }

        stage('Test') {
            steps {
                echo "Running containerized tests..."
                script {
                    try {
                        dir(APP_DIR) {
                            sh """
                                docker ps -a --format '{{.Ports}}' | grep -q ":${TEST_PORT}->" && \
                                (echo "Port ${TEST_PORT} already in use" && exit 1) || true
                            """
                            sh """
                                docker inspect ${IMAGE_NAME}:${BUILD_TAG} >/dev/null 2>&1 || \
                                (echo "Image ${IMAGE_NAME}:${BUILD_TAG} not found" && exit 1)
                            """
                            sh """
                                docker stop ${TEST_CONTAINER_NAME} || true
                                docker rm ${TEST_CONTAINER_NAME} || true
                            """
                            sh """
                                docker run -d --name ${TEST_CONTAINER_NAME} -p ${TEST_PORT}:3306 \
                                -e MYSQL_ROOT_PASSWORD=rootpass \
                                -e MYSQL_DATABASE=testdb \
                                -e MYSQL_USER=testuser \
                                -e MYSQL_PASSWORD=testpass \
                                -v mysql_data:/var/lib/mysql \
                                -v mysql_logs:/var/log/mysql \
                                --health-cmd="mysqladmin ping -h 127.0.0.1 -P 3306 -u root --password=rootpass || exit 1" \
                                --health-interval=10s \
                                --health-timeout=10s \
                                --health-retries=15 \
                                --health-start-period=90s \
                                ${IMAGE_NAME}:${BUILD_TAG}
                            """
                            echo "Waiting for MySQL to start..."
                            retry(30) {
                                sleep(10)
                                sh """
                                    if ! docker ps | grep -q ${TEST_CONTAINER_NAME}; then
                                        echo "Container not running, checking logs:"
                                        docker logs ${TEST_CONTAINER_NAME}
                                        exit 1
                                    fi
                                    HEALTH_STATUS=\$(docker inspect --format='{{.State.Health.Status}}' ${TEST_CONTAINER_NAME})
                                    if [ "\$HEALTH_STATUS" != "healthy" ]; then
                                        echo "Container not healthy, status: \$HEALTH_STATUS"
                                        docker logs ${TEST_CONTAINER_NAME}
                                        exit 1
                                    fi
                                    docker exec ${TEST_CONTAINER_NAME} mysqladmin ping -h 127.0.0.1 -P 3306 -u root --password=rootpass --connect-timeout=5
                                """
                            }
                            echo "MySQL is ready!"
                            echo "Running MySQL tests..."
                            sh """
                                docker exec ${TEST_CONTAINER_NAME} mysql -uroot -prootpass -h 127.0.0.1 -P 3306 -e "SHOW DATABASES;"
                                docker exec ${TEST_CONTAINER_NAME} mysql -uroot -prootpass -h 127.0.0.1 -P 3306 -e "USE testdb; SHOW TABLES;"
                                docker exec ${TEST_CONTAINER_NAME} mysql -uroot -prootpass -h 127.0.0.1 -P 3306 -e "USE testdb; CREATE TABLE IF NOT EXISTS test_table (id INT PRIMARY KEY, name VARCHAR(50));"
                                docker exec ${TEST_CONTAINER_NAME} mysql -uroot -prootpass -h 127.0.0.1 -P 3306 -e "USE testdb; INSERT IGNORE INTO test_table (id, name) VALUES (1, 'test');"
                                docker exec ${TEST_CONTAINER_NAME} mysql -uroot -prootpass -h 127.0.0.1 -P 3306 -e "USE testdb; SELECT * FROM test_table;"
                                docker exec ${TEST_CONTAINER_NAME} mysql -utestuser -ptestpass -h 127.0.0.1 -P 3306 -e "SHOW DATABASES;"
                            """
                            echo "All MySQL tests passed!"
                        }
                    } catch (Exception e) {
                        echo "Test failed: ${e.getMessage()}"
                        sh "docker logs ${TEST_CONTAINER_NAME} || echo 'Could not retrieve logs'"
                        throw e
                    } finally {
                        sh """
                            docker stop ${TEST_CONTAINER_NAME} || true
                            docker rm ${TEST_CONTAINER_NAME} || true
                        """
                    }
                }
            }
        }

        stage('Security Scan') {
            when {
                anyOf {
                    environment name: 'SKIP_SECURITY_SCAN', value: 'false'
                    environment name: 'FORCE_SECURITY_SCAN', value: 'true'
                }
            }
            steps {
                echo "Running security scan with Trivy..."
                script {
                    try {
                        def trivyAvailable = sh(
                            script: "docker run --rm aquasec/trivy:latest --version",
                            returnStatus: true
                        )
                        if (trivyAvailable != 0) {
                            echo "Trivy not available, skipping security scan"
                            currentBuild.result = 'UNSTABLE'
                            return
                        }
                        echo "Running comprehensive vulnerability scan..."
                        sh """
                            docker run --rm -v /var/run/docker.sock:/var/run/docker.sock \
                            aquasec/trivy:latest image \
                            --format table \
                            --severity LOW,MEDIUM,HIGH,CRITICAL \
                            ${IMAGE_NAME}:${BUILD_TAG} || true
                        """
                        echo "Checking for CRITICAL vulnerabilities only..."
                        def criticalScanResult = sh(
                            script: """
                                docker run --rm -v /var/run/docker.sock:/var/run/docker.sock \
                                aquasec/trivy:latest image \
                                --exit-code 1 --severity CRITICAL \
                                --format table \
                                ${IMAGE_NAME}:${BUILD_TAG} || true
                            """,
                            returnStatus: true
                        )
                        if (criticalScanResult == 0) {
                            echo "No CRITICAL vulnerabilities found"
                        } else {
                            echo "CRITICAL vulnerabilities found - marking build as unstable"
                            currentBuild.result = 'UNSTABLE'
                        }
                        echo "Security scan completed"
                    } catch (Exception e) {
                        echo "Security scan failed: ${e.getMessage()}"
                        currentBuild.result = 'UNSTABLE'
                    }
                }
            }
        }

        stage('Push to Docker Hub') {
            when {
                anyOf {
                    branch 'main'
                    branch 'develop'
                    environment name: 'ENABLE_DOCKER_PUSH', value: 'true'
                    environment name: 'FORCE_BRANCH_MAIN', value: 'true'
                    environment name: 'FORCE_BRANCH_DEVELOP', value: 'true'
                }
            }
            steps {
                echo "Pushing image to Docker Hub..."
                script {
                    try {
                        try {
                            docker.withRegistry("${DOCKER_REGISTRY}", 'dockerhub-credentials') {
                                def image = docker.image("${IMAGE_NAME}:${BUILD_TAG}")
                                image.push()
                                image.push("jenkins-mysql-latest")
                                if (env.BRANCH_NAME == 'main' || env.FORCE_BRANCH_MAIN == 'true') {
                                    image.push("production")
                                    image.push("v1.0.0")
                                } else if (env.BRANCH_NAME == 'develop' || env.FORCE_BRANCH_DEVELOP == 'true') {
                                    image.push("staging")
                                    image.push("develop-latest")
                                }
                                echo "Image pushed successfully with credentials"
                            }
                        } catch (Exception credError) {
                            echo "Docker Hub credentials not found, attempting push without registry authentication..."
                            sh """
                                docker push ${IMAGE_NAME}:${BUILD_TAG} || echo "Push failed - check Docker Hub login"
                                docker push ${IMAGE_NAME}:jenkins-mysql-latest || echo "Push failed - check Docker Hub login"
                            """
                            echo "Image push attempted (check Docker Hub for results)"
                        }
                    } catch (Exception e) {
                        echo "Docker Hub push failed: ${e.getMessage()}"
                        echo "To fix: Run 'docker login' on Jenkins agent or configure 'dockerhub-credentials'"
                        currentBuild.result = 'UNSTABLE'
                    }
                }
            }
        }

        stage('Deploy to Staging') {
            when {
                anyOf {
                    branch 'develop'
                    environment name: 'ENABLE_STAGING_DEPLOY', value: 'true'
                    environment name: 'FORCE_BRANCH_DEVELOP', value: 'true'
                }
            }
            steps {
                echo "Deploying to staging..."
                script {
                    deployToEnvironment('staging', '3307')
                }
            }
        }

        stage('Deploy to Production') {
            when {
                anyOf {
                    branch 'main'
                    environment name: 'ENABLE_PRODUCTION_DEPLOY', value: 'true'
                    environment name: 'FORCE_BRANCH_MAIN', value: 'true'
                }
            }
            steps {
                script {
                    if (env.SKIP_PRODUCTION_APPROVAL != 'true') {
                        try {
                            timeout(time: 5, unit: 'MINUTES') {
                                input message: 'Deploy to production?', ok: 'Deploy'
                            }
                        } catch (Exception e) {
                            echo "Production deployment approval timeout or skipped"
                            return
                        }
                    }
                    echo "Deploying to production..."
                    deployToEnvironment('production', '3308')
                }
            }
        }
    }

    post {
        always {
            echo "Cleaning up..."
            script {
                sh """
                    docker stop ${TEST_CONTAINER_NAME} || true
                    docker rm ${TEST_CONTAINER_NAME} || true
                    docker system prune -f --filter "until=24h"
                """
            }
        }

        success {
            echo "Pipeline completed successfully!"
            script {
                try {
                    if (env.EMAIL_CONFIGURED == 'true') {
                        emailext(
                            subject: "MySQL Build Success: ${env.JOB_NAME} #${env.BUILD_NUMBER}",
                            body: """
                                MySQL build succeeded!

                                Job: ${env.JOB_NAME}
                                Build Number: ${env.BUILD_NUMBER}
                                Branch: ${env.BRANCH_NAME ?: 'main'}
                                Image: ${IMAGE_NAME}:${BUILD_TAG}

                                GitHub: ${GITHUB_REPO}
                                Docker Hub: https://hub.docker.com/r/${DOCKER_USERNAME}/${DOCKER_REPO}
                                Build URL: ${env.BUILD_URL}
                            """,
                            recipientProviders: [developers()]
                        )
                    } else {
                        echo "Email notification skipped - EMAIL_CONFIGURED not set to true"
                    }
                } catch (Exception e) {
                    echo "Failed to send success email: ${e.getMessage()}"
                }
            }
        }

        failure {
            echo "Pipeline failed!"
            script {
                try {
                    if (env.EMAIL_CONFIGURED == 'true') {
                        emailext(
                            subject: "MySQL Build Failed: ${env.JOB_NAME} #${env.BUILD_NUMBER}",
                            body: """
                                MySQL build failed!

                                Job: ${env.JOB_NAME}
                                Branch: ${env.BRANCH_NAME ?: 'main'}
                                Build URL: ${env.BUILD_URL}

                                Please check the console output for details:
                                ${env.BUILD_URL}console
                            """,
                            recipientProviders: [developers(), requestor()]
                        )
                    } else {
                        echo "Email notification skipped - EMAIL_CONFIGURED not set to true"
                    }
                } catch (Exception e) {
                    echo "Failed to send failure email: ${e.getMessage()}"
                }
            }
        }

        unstable {
            echo "Pipeline completed with warnings."
        }
    }
}

def deployToEnvironment(environment, port) {
    def containerName = "mysql-app-${environment}"
    try {
        echo "Deploying ${IMAGE_NAME}:${BUILD_TAG} to ${environment} on port ${port}"
        sh """
            docker stop ${containerName} || true
            docker rm ${containerName} || true
            docker run -d \
                --name ${containerName} \
                -p ${port}:${APP_PORT} \
                -e MYSQL_ROOT_PASSWORD=rootpass \
                -e MYSQL_DATABASE=mydb \
                -e MYSQL_USER=sqluser \
                -e MYSQL_PASSWORD=MyAppUserPass456 \
                -e ENVIRONMENT=${environment} \
                --restart=unless-stopped \
                --memory=512m \
                --cpus=0.5 \
                --health-cmd="mysqladmin ping -h 127.0.0.1 -P 3306 -u root --password=rootpass || exit 1" \
                --health-interval=10s \
                --health-timeout=10s \
                --health-retries=20 \
                --health-start-period=120s \
                -v mysql_data_${environment}:/var/lib/mysql \
                -v mysql_logs_${environment}:/var/log/mysql \
                ${IMAGE_NAME}:${BUILD_TAG}
        """
        echo "Waiting for MySQL deployment to stabilize..."
        sleep 60
        echo "Checking MySQL deployment health..."
        retry(10) {
            sh """
                echo "Testing MySQL connection..."
                docker exec ${containerName} mysqladmin ping -h 127.0.0.1 -P 3306 -u root --password=rootpass --connect-timeout=5 || exit 1
                docker logs ${containerName}
            """
        }
        echo "Successfully deployed MySQL to ${environment} on port ${port}"
        echo "Connect to MySQL at: localhost:${port}"
        echo "Connection command: mysql -h127.0.0.1 -P${port} -uroot -prootpass"
        sh "docker ps | grep ${containerName} || echo 'Container not found in ps'"
    } catch (Exception e) {
        echo "Deployment to ${environment} failed: ${e.getMessage()}"
        echo "Checking what went wrong..."
        sh """
            docker logs ${containerName} || echo "No logs available"
            docker ps -a | grep ${containerName} || echo "Container not found"
        """
        throw e
    }
}
